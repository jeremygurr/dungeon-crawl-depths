<!DOCTYPE html>

<html>
<head>
    <meta charset="utf-8" />
    <title>Training: Crawl Game</title>
    <style>
      * { padding: 0; margin: 0; }
      canvas { background: #fff; display: block; margin: 0 auto; }
    </style>
</head>
<body>

<script>
"use strict";

const canvasProps = {
  xOffset: 0,
  yOffset: 0,
  width: 1600,
  height: 572,
};

document.write('<canvas id="mainCanvas" width="' + canvasProps.width + '" height="' + canvasProps.height + '"></canvas>')

</script>

<!-- provides _.cloneDeep() -->
<script src="https://cdn.jsdelivr.net/npm/lodash@4.17.15/lodash.min.js"></script>
<!-- provides Math.seedrandom -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/seedrandom/3.0.5/seedrandom.min.js"></script>

<script>

const canvas = document.getElementById("mainCanvas")
const ctx = canvas.getContext("2d")

// immutable
class Pair {

  constructor(x, y) {
    this.x = x
    this.y = y
  }

  equals(pair) {
    return this.x === pair.x && this.y === pair.y
  }

  directionTo(pair) {
    const dx = pair.x - this.x
    const dy = pair.y - this.y
    let direction = '?'
    if(dx === 0) {
      if(dy > 0) {
        direction = 'S'
      } else if(dy < 0) {
        direction = 'N'
      }
    } else if(dy === 0) {
      if(dx > 0) {
        direction = 'E'
      } else if(dx < 0) {
        direction = 'W'
      }
    } else if(dx > 0) {
      if(dy > 0) {
        direction = 'SE'
      } else if(dy < 0) {
        direction = 'NE'
      }
    } else if(dx < 0) {
      if(dy > 0) {
        direction = 'SW'
      } else if(dy < 0) {
        direction = 'NW'
      }
    }
    return direction
  }

  add(pair) {
    if(!pair) return this
    return new Pair(this.x + pair.x, this.y + pair.y)
  }

  wrap(size) {
    if(typeof size == 'number') {
      size = new Pair(size, size)
    }
    let newX = wrap(this.x, size.x)
    let newY = wrap(this.y, size.y)
    return new Pair(newX, newY)
  }

  subtract(pair) {
    if(typeof pair == 'number') {
      pair = new Pair(pair, pair)
    }
    return new Pair(this.x - pair.x, this.y - pair.y)
  }

  multiply(pair) {
    if(typeof pair == 'number') {
      pair = new Pair(pair, pair)
    }
    return new Pair(this.x * pair.x, this.y * pair.y)
  }

  divide(pair) {
    if(typeof pair == 'number') {
      pair = new Pair(pair, pair)
    }
    return new Pair(this.x / pair.x, this.y / pair.y)
  }

  negate() {
    return new Pair(-this.x, -this.y)
  }

  round(n) {
    const newX = Math.round(this.x * 10 ** n) / 10 ** n
    const newY = Math.round(this.y * 10 ** n) / 10 ** n
    return new Pair(newX, newY)
  }

  floor() {
    return new Pair(Math.floor(this.x), Math.floor(this.y))
  }

  lessThan(pair) {
    return this.x < pair.x && this.y < pair.y
  }

  lessThanOrEqualTo(pair) {
    return this.x <= pair.x && this.y <= pair.y
  }

  within(minPair, maxPairExclusive) {
    return minPair.lessThanOrEqualTo(this) && this.lessThan(maxPairExclusive)
  }

  // returns a list of adjacent positions that fit within the 
  //   given size
  adjacent(size) {
    let result = []
    for(let c = this.x - 1; c <= this.x + 1; c++) {
      for(let r = this.y - 1; r <= this.y + 1; r++) {
        if(c == this.x && r == this.y) continue
        result.push(
          new Pair(
            wrap(c, size.x), 
            wrap(r, size.y),
          )
        )
      }
    }
    return result
  }

  randomAdjacent(size) {
    const a = this.adjacent(size)
    return a[random(8)]
  }

  // returns the unwrapped perimeter cells of a given radius
  // radius should be a whole number
  perimeter(radius) {
    let result = []
    for(let x = this.x - radius; x < this.x + radius + 1; x++) {
      result.push(new Pair(x, this.y - radius))
      result.push(new Pair(x, this.y + radius))
    }
    for(let y = this.y - radius; y < this.y + radius + 1; y++) {
      result.push(new Pair(this.x - radius, y))
      result.push(new Pair(this.x + radius, y))
    }
    return result
  }

  distance(target) {
    return Math.sqrt(
      (target.x - this.x) ** 2 
    + (target.y - this.y) ** 2
    )
  }

  wrappedDistance(target, size) {
    let dx = Math.abs(target.x - this.x)
    if(dx > size.x / 2) dx -= size.x
    let dy = Math.abs(target.y - this.y)
    if(dy > size.y / 2) dy -= size.y
    return Math.sqrt(
      dx ** 2 
    + dy ** 2
    )
  }

  unwrap(target, size) {
    let newX = this.x
    if(Math.abs(target.x - this.x) > size.x / 2) {
      if(newX > size.x / 2) {
        newX -= size.x
      } else {
        newX += size.x
      }
    }
    let newY = this.y
    if(Math.abs(target.y - this.y) > size.y / 2) {
      if(newY > size.y / 2) {
        newY -= size.y
      } else {
        newY += size.y
      }
    }
    return new Pair(newX, newY)
  }

}

// this only needs to be created once, since it is immutable
emptyPair = new Pair(0, 0)
halfPair = new Pair(0.5, 0.5)

function pair(m) {
  return new Pair(m, m)
}

// immutable
const fontStyle = {
  fixed: { name: "Courier", size: 26 },
  compact: { name: "Courier", size: 13 },
}

// immutable
// each value is initialized with name and class
const senses = {
  sight: { key: 'v', },
  sound: { key: 'h', },
  smell: { key: 's', },
  feeling: { key: 'f', },
  energy: { key: 'e', },
}

// immutable
const species = {

  default: {

    hands: 2,

    attributes: {
      strength: 10,
      dexterity: 10,
      intelligence: 10,
    },

    senses: {
      sight: 10,
      sound: 10,
      smell: 10,
      feeling: 10,
      energy: 10,
    },

    experiencePerLevel: 10,

    aptitudes: {
      default: 1,
    },

    maxPoolSizes: {
      criticalHealth: 10,
      majorHealth: 10,
      minorHealth: 10,
      stamina: 20,
      mana: 20,
      willpower: 20,
      default: 100,
    },

    maxChannelSizes: [],
    maxChannelSizeDefault: 2,
    
    energyEfficiency: {
      default: 1,
    },

    energyDelta: {
      health: -0.1,
      stamina: -0.1,
      mana: -0.1,
      willpower: -0.1,
    },

    poolAwakeningLevels: [ 10, 30, 90 ]

  },

  human: {
    experiencePerLevel: 12,
  },

}

// immutable
// name is automatically added
const skillTypes = {
  defense: {},
  misc: {},
}

// immutable
// name is automatically added
const skills = {
  dodge: { type: skillTypes.defense },
  meditation: { type: skillTypes.misc },
}

// immutable
// name is automatically added
// pools is automatically added
const poolTypes = {
  interna: { key: 'i', },
  lumina:  { key: 'l', },
  etherea: { key: 'e', },
  spectra: { key: 's', },
  exotica: { key: 'x', },
}

function generateGradient(width, height, list) {
  const multiplier = 20
  const g = ctx.createLinearGradient(0, 0, width * multiplier, height);
  const increment = 1 / (list.length * multiplier + 1)
  let stop = 0
  for(let x = 0; x < multiplier; x++) {
    for(let i = 0; i < list.length; i++) {
      g.addColorStop(stop, list[i]);
      stop += increment
    }
  }
  return g
}

let gradient = {}

{

  const w = 100
  gradient.vrainbow = generateGradient(w, 0, [
    "#C00000",
    "#C06000",
    "#C0C000",
    "#00C000",
    "#00C0C0",
    "#0000C0",
  ])

  gradient.lightRainbow = generateGradient(w, 0, [
    '#FF9F9F',
    '#FFBF8F',
    '#FFDB89',
    '#FFED8E',
    '#FFFF80',
    '#EFFF80',
    '#CFFF80',
    '#80FFFF',
    '#8FBAFF',
    '#AC9FFF',
    '#C9AFFF',
  ])

  gradient.vibrantRainbow = generateGradient(w, 0, [
    '#FF2F2F',
    '#FF6F1F',
    '#FFAB12',
    '#FFCB0C',
    '#FFFF00',
    '#CFFF00',
    '#7FFF00',
    '#00FFFF',
    '#1F74FF',
    '#583FFF',
    '#824FFF',
  ])

  gradient.diamond = generateGradient(w, 0, [
    '#FFFFFF',
    '#E0FFFF',
    '#FFFFFF',
    '#E0FFFF',
    '#FFFFFF',
    '#E0FFFF',
    '#FFFFFF',
    '#E0FFFF',
    '#FFFFFF',
    '#E0FFFF',
    '#FFFFFF',
    '#E0FFFF',
  ])

  gradient.gold = generateGradient(w, 0, [
    '#FFFFFF',
    '#FFFFD0',
    '#FFFFFF',
    '#FFFFD0',
    '#FFFFFF',
    '#FFFFD0',
    '#FFFFFF',
    '#FFFFD0',
    '#FFFFFF',
    '#FFFFD0',
    '#FFFFFF',
    '#FFFFD0',
  ])

  gradient.silver = generateGradient(w, 0, [
    '#FFFFFF',
    '#E0E0E0',
    '#FFFFFF',
    '#E0E0E0',
    '#FFFFFF',
    '#E0E0E0',
    '#FFFFFF',
    '#E0E0E0',
    '#FFFFFF',
    '#E0E0E0',
    '#FFFFFF',
    '#E0E0E0',
  ])

  gradient.copper = generateGradient(w, 0, [
    '#FFFFFF',
    '#FFE0C0',
    '#FFFFFF',
    '#FFE0C0',
    '#FFFFFF',
    '#FFE0C0',
    '#FFFFFF',
    '#FFE0C0',
    '#FFFFFF',
    '#FFE0C0',
    '#FFFFFF',
    '#FFE0C0',
  ])

}

const colorize = {
  magenta: message => [{ style: '#C000C0', text: message }],
  rainbow: message => [{ style: gradient.vrainbow, text: message }],
}

// each has a dark and light version
const colors = {
  black:   { bgStyle: '#000000', style: '#FFF' },
  gray:    { bgStyle: '#808080', style: '#FFF' },
  white1:  { bgStyle: '#D0D0D0', style: '#000' },
  white2:  { bgStyle: '#E8E8E8', style: '#000' },
  white3:  { bgStyle: '#FFFFFF', style: '#000' },
  copper:  { 
    bgStyle: gradient.copper,
    style: '#000' 
  },
  silver:  { 
    bgStyle: gradient.silver,
    style: '#000' 
  },
  gold:  { 
    bgStyle: gradient.gold,
    style: '#000' 
  },
  diamond:  { 
    bgStyle: gradient.diamond,
    style: '#000' 
  },
  lightred:   { bgStyle: '#FF9F9F', style: '#000' },
  lightorange:{ bgStyle: '#FFDD88', style: '#000' },
  lightyellow:{ bgStyle: '#FFFF80', style: '#000' },
  lightgreen: { bgStyle: '#BFFF80', style: '#000' },
  lightblue:  { bgStyle: '#8FB9FF', style: '#000' },
  lightviolet:{ bgStyle: '#C89FFF', style: '#000' },
  red:        { bgStyle: '#FF2F2F', style: '#FFF' },
  orange:     { bgStyle: '#FFAB12', style: '#000' },
  yellow:     { bgStyle: '#FFFF00', style: '#000' },
  green:      { bgStyle: '#7FFF00', style: '#000' },
  cyan:       { bgStyle: '#00FFFF', style: '#000' },
  blue:       { bgStyle: '#0084FF', style: '#FFF' },
  indigo:     { bgStyle: '#413FFF', style: '#FFF' },
  violet:     { bgStyle: '#825FFF', style: '#FFF' },
  rainbow: { 
    bgStyle: gradient.lightRainbow, 
    style: '#000',
  },
  brown:   { bgStyle: '#CF9509', style: '#FFF'  },
  purple:  { bgStyle: '#D56FFF', style: '#FFF'  },
}

// immutable
const pools = {
  // name is added to these automatically
  // channels is added to these automatically
  //   which contains an array of channel indexes
  // index is added to these automatically
  // class is added to these automatically
  criticalHealth: { 
    type: poolTypes.interna, 
    key: '1', 
    shortName: 'I1', 
    longName: 'critical health',
    tier: 1,
    color: colors.lightblue,
  },
  majorHealth: { 
    type: poolTypes.interna, 
    key: '2', 
    shortName: 'I2', 
    longName: 'major health',
    tier: 1,
    color: colors.lightgreen,
  },
  minorHealth: { 
    type: poolTypes.interna, 
    key: '3', 
    shortName: 'I3', 
    longName: 'minor health',
    tier: 1,
    color: colors.lightred,
  },
  stamina: { 
    type: poolTypes.interna, 
    key: 's', 
    shortName: 'IS', 
    longName: 'stamina',
    tier: 1,
    color: colors.lightorange,
  },
  mana: { 
    type: poolTypes.interna, 
    key: 'm', 
    shortName: 'IM', 
    longName: 'mana',
    tier: 1,
    color: colors.lightyellow,
  },
  willpower: { 
    type: poolTypes.interna, 
    key: 'w', 
    shortName: 'IW', 
    longName: 'willpower',
    tier: 1,
    color: colors.lightviolet,
  },
  black: { 
    type: poolTypes.lumina, 
    key: 'b', 
    shortName: 'LB', 
    longName: 'black',
    tier: 0,
    color: colors.black,
  },
  gray: { 
    type: poolTypes.lumina, 
    key: 'g', 
    shortName: 'LG', 
    longName: 'gray',
    tier: 1,
    color: colors.gray,
  },
  star: { 
    type: poolTypes.lumina, 
    key: 't', 
    shortName: 'LT', 
    longName: 'star',
    tier: 2,
    color: colors.white1,
  },
  moon: { 
    type: poolTypes.lumina, 
    key: 'm', 
    shortName: 'LM', 
    longName: 'moon',
    tier: 3,
    color: colors.white2,
  },
  sun: { 
    type: poolTypes.lumina, 
    key: 's', 
    shortName: 'LS', 
    longName: 'sun',
    tier: 4,
    color: colors.white3,
  },
  copper: { 
    type: poolTypes.etherea, 
    key: 'c', 
    shortName: 'EC', 
    longName: 'copper',
    tier: 3,
    color: colors.copper,
  },
  silver: { 
    type: poolTypes.etherea, 
    key: 's', 
    shortName: 'ES', 
    longName: 'silver',
    tier: 3,
    color: colors.silver,
  },
  gold: { 
    type: poolTypes.etherea, 
    key: 'g', 
    shortName: 'EG', 
    longName: 'gold',
    tier: 3,
    color: colors.gold,
  },
  diamond: { 
    type: poolTypes.etherea, 
    key: 'd', 
    shortName: 'ED', 
    longName: 'diamond',
    tier: 3,
    color: colors.diamond,
  },
  red: { 
    type: poolTypes.spectra, 
    key: 'r', 
    shortName: 'SR', 
    longName: 'red',
    tier: 2,
    color: colors.red,
  },
  orange: { 
    type: poolTypes.spectra, 
    key: 'o', 
    shortName: 'SO', 
    longName: 'orange',
    tier: 2,
    color: colors.orange,
  },
  yellow: { 
    type: poolTypes.spectra, 
    key: 'y', 
    shortName: 'SY', 
    longName: 'yellow',
    tier: 2,
    color: colors.yellow,
  },
  green: { 
    type: poolTypes.spectra, 
    key: 'g', 
    shortName: 'SG', 
    longName: 'green',
    tier: 2,
    color: colors.green,
  },
  cyan: { 
    type: poolTypes.spectra, 
    key: 'c', 
    shortName: 'SC', 
    longName: 'cyan',
    tier: 2,
    color: colors.cyan,
  },
  blue: { 
    type: poolTypes.spectra, 
    key: 'b', 
    shortName: 'SB', 
    longName: 'blue',
    tier: 2,
    color: colors.blue,
  },
  indigo: { 
    type: poolTypes.spectra, 
    key: 'i', 
    shortName: 'SI', 
    longName: 'indigo',
    tier: 2,
    color: colors.indigo,
  },
  violet: { 
    type: poolTypes.spectra, 
    key: 'v', 
    shortName: 'SV', 
    longName: 'violet',
    tier: 2,
    color: colors.violet,
  },
  rainbow: { 
    type: poolTypes.exotica, 
    key: 'r', 
    shortName: 'XR', 
    longName: 'rainbow',
    tier: 1,
    color: colors.rainbow,
  },
  brown: { 
    type: poolTypes.exotica, 
    key: 'b', 
    shortName: 'XB', 
    longName: 'brown',
    tier: 1,
    color: colors.brown,
  },
  purple: { 
    type: poolTypes.exotica, 
    key: 'p', 
    shortName: 'XP', 
    longName: 'purple',
    tier: 1,
    color: colors.purple,
  },
}

// only allow a pool to contain this many times it's capacity
const poolOverloadFactorMax = 1

// index is added to each of these automatically
// name is automatically added to each
const poolChannels = [
  {
    from: [pools.sun],
    to: [
      pools.diamond,
      pools.gold,
      pools.silver,
      pools.copper,
    ],
  },
  {
    from: [pools.sun],
    to: [pools.moon],
  },
  {
    from: [
      pools.sun,
      pools.moon,
      pools.star,
      pools.gray,
      pools.black,
    ],
    to: [pools.brown],
  },
  {
    from: [
      pools.copper,
      pools.gold,
    ],
    to: [pools.brown],
  },
  {
    from: [pools.moon],
    to: [
      pools.red,
      pools.orange,
      pools.yellow,
      pools.green,
      pools.cyan,
      pools.blue,
      pools.indigo,
      pools.violet,
    ],
  },
  {
    from: [pools.moon],
    to: [pools.star],
  },
  {
    from: [pools.diamond],
    to: [pools.red],
  },
  {
    from: [pools.diamond],
    to: [pools.cyan],
  },
  {
    from: [pools.diamond],
    to: [pools.blue],
  },
  {
    from: [pools.diamond],
    to: [pools.indigo],
  },
  {
    from: [pools.diamond],
    to: [pools.violet],
  },
  {
    from: [pools.diamond],
    to: [pools.star],
  },
  {
    from: [pools.gold],
    to: [pools.yellow],
  },
  {
    from: [pools.gold],
    to: [pools.green],
  },
  {
    from: [pools.gold],
    to: [pools.cyan],
  },
  {
    from: [pools.gold],
    to: [pools.blue],
  },
  {
    from: [pools.gold],
    to: [pools.star],
  },
  {
    from: [pools.silver],
    to: [pools.orange],
  },
  {
    from: [pools.silver],
    to: [pools.yellow],
  },
  {
    from: [pools.silver],
    to: [pools.green],
  },
  {
    from: [pools.silver],
    to: [pools.star],
  },
  {
    from: [pools.copper],
    to: [pools.red],
  },
  {
    from: [pools.copper],
    to: [pools.orange],
  },
  {
    from: [pools.copper],
    to: [pools.star],
  },
  {
    from: [pools.star],
    to: [pools.gray],
  },
  {
    from: [pools.red],
    to: [pools.gray],
  },
  {
    from: [pools.orange],
    to: [pools.gray],
  },
  {
    from: [pools.yellow],
    to: [pools.gray],
  },
  {
    from: [pools.green],
    to: [pools.gray],
  },
  {
    from: [pools.cyan],
    to: [pools.gray],
  },
  {
    from: [pools.blue],
    to: [pools.gray],
  },
  {
    from: [pools.indigo],
    to: [pools.gray],
  },
  {
    from: [pools.violet],
    to: [pools.gray],
  },
  {
    from: [pools.red],
    to: [pools.minorHealth],
  },
  {
    from: [pools.orange],
    to: [pools.stamina],
  },
  {
    from: [pools.yellow],
    to: [pools.mana],
  },
  {
    from: [pools.green],
    to: [pools.majorHealth],
  },
  {
    from: [pools.blue],
    to: [pools.criticalHealth],
  },
  {
    from: [pools.violet],
    to: [pools.willpower],
  },
  {
    from: [
      pools.red,
      pools.orange,
      pools.yellow,
      pools.green,
      pools.cyan,
      pools.blue,
      pools.indigo,
      pools.violet,
    ],
    to: [pools.rainbow],
  },
  {
    from: [
      pools.diamond,
      pools.gold,
      pools.silver,
      pools.copper,
    ],
    to: [pools.rainbow],
  },
  {
    from: [
      pools.diamond,
      pools.silver,
    ],
    to: [pools.purple],
  },
  {
    from: [
      pools.red,
      pools.blue,
    ],
    to: [pools.purple],
  },
  {
    from: [pools.criticalHealth],
    to: [pools.black],
  },
  {
    from: [pools.majorHealth],
    to: [pools.black],
  },
  {
    from: [pools.minorHealth],
    to: [pools.black],
  },
  {
    from: [pools.stamina],
    to: [pools.black],
  },
  {
    from: [pools.mana],
    to: [pools.black],
  },
  {
    from: [pools.willpower],
    to: [pools.black],
  },
  {
    from: [pools.gray],
    to: [pools.black],
  },
]

const size = {
  large: 2,
  medium: 1,
  small: 0,
}

// immutable
const template = {

  object: {
    dirtFloor: { 
      type: 'floor', 
      occupant: false, 
      size: size.small,
      name: 'dirt', 
      showAs: '.' 
    },
    rockWall: { 
      type: 'wall', 
      occupant: true, 
      size: size.large,
      name: 'rock', 
      showAs: '🀆', 
      offset: new Pair(0, 1),
      blocksSmell: true,
      heatCapacity: 1000,
    },
    somethingBig: {
      showAs: 'X', 
    },
    somethingSmall: {
      showAs: 'x', 
    },
  },

  generated: {

    fillRatio: 0.020,

    sub: {

      potion: {
        type: 'potion',
        showAs: '!', 
        occupant: false,
        chanceWeight: 0,
        size: size.small,
        sub: {
          experience: { 
            chanceWeight: 0, 
          },
        },
      },

      gold: {
        type: 'gold',
        showAs: '💰', 
        occupant: false,
        chanceWeight: 1000,
        size: size.small,
        sub: {
          gold: { 
            chanceWeight: 1000, 
            count: 1,
          },
        },
      },

      creature: {
        type: 'creature',
        occupant: true,
        chanceWeight: 1000,
        size: size.medium,
        sub: {
          rat:  { 
            chanceWeight: 1000, 
            showAs: '🐭', 
            health: 2,  
            attack: { min: 0, max: 1 }, 
            act: 'simplePursuit',
            sound: {
              name: 'a squeak',
              volume: 4,
              chance: 0.2,
            },
            smell: {
              name: 'dry musky',
              amount: 10,
            },
            heatCapacity: 10,
            heat: {
              baseChange: -1,
              move: 2,
              internalGenerator: 2,
              ideal: 100,
              tolerance: 20,
            },
          },
          lion: { 
            chanceWeight: 300,
            showAs: '🦁',
            health: 10,
            attack: { min: 0, max: 4 },
            act: 'simplePursuit',
          },
        },
      },

      tool: {
        type: 'tool',
        occupant: false,
        chanceWeight: 1000,
        durability: 1000,
        showAs: '🛠',
        equipSlot: 'hand',
        hands: 1,
        size: size.small,
        sub: {
          torch: {
            chanceWeight: 1000,
            durability: 100,
            glow: 3,
            showAs: '🔦',
          },
          candle: {
            chanceWeight: 1000,
            glow: 2,
            showAs: '🕯',
          },
        },
      },

      weapon: {
        type: 'weapon',
        occupant: false,
        chanceWeight: 1000,
        equipSlot: 'hand',
        hands: 1,
        durability: 100,
        size: size.small,
        sub: {
          throwable: {
            skill: 'throwing',
            range: 12,
            sub: {
              rock: { 
                chanceWeight: 1000, 
                showAs: 'o', 
                hitChance: -2,
                attackSpeed: 0,
                damage: [{
                  type: 'bash',
                  base: 3, 
                  range: 2, 
                  average: 2
                }],
                mulchChance: 1,
              },
              boulder: { 
                chanceWeight: 100, 
                showAs: 'O',
                hands: 2,
                hitChance: -1,
                attackSpeed: -1,
                damage: [{
                  type: 'bash',
                  base: 20, 
                  range: 10, 
                  average: 2
                }],
                returnChance: 0.1,
                mulchChance: 1,
              },
              boomerang: { 
                chanceWeight: 100, 
                showAs: ')',
                hitChance: -2,
                attackSpeed: 0,
                damage: [{
                  type: 'chop',
                  base: 5, 
                  range: 3, 
                  average: 1
                }],
                returnChance: 0.3,
              },
            },
          },
          
          longBlade: { 
            skill: 'longBlade',
            range: 1,
            sub: {
              sword: {
                chanceWeight: 100, 
                showAs: '🗡',
                hitChance: 0,
                attackSpeed: 1,
                damage: [{
                  type: 'chop',
                  base: 8, 
                  range: 4, 
                  average: 1
                }],
              },
            },
          },

          axe: {
            skill: 'axe',
            range: 1,
            sub: {
              handAxe: {
                chanceWeight: 100, 
                showAs: '🪓',
                hitChance: 0,
                attackSpeed: 0,
                damage: [{
                  type: 'chop',
                  base: 8, 
                  range: 4, 
                  average: 2
                }],
              },
            },
          },

          polearm: {
            skill: 'polearm',
            range: 2,
            sub: {
              spear: {
                chanceWeight: 100, 
                showAs: '🔱',
                hitChance: 0,
                attackSpeed: -1,
                damage: [{
                  type: 'pierce',
                  base: 8, 
                  range: 8, 
                  average: 2
                }],
              },
            },
          },

          mace: {
            skill: 'mace',
            sub: {
              mace: {
                chanceWeight: 100, 
                showAs: '⚒',
                hitChance: 0,
                attackSpeed: -1,
                damage: [{
                  type: 'bash',
                  base: 8, 
                  range: 4, 
                  average: 2
                }],
              },
            },
          },
        },
      },

      food: {
        type: 'food',
        occupant: false,
        chanceWeight: 1000,
        showAs: '🍖',
        size: size.small,
        sub: {
          beef: { 
            chanceWeight: 1000,
            energy: {
              red: 20,
            },
          },
          bacon: { 
            chanceWeight: 300,
            energy: {
              red: 10,
              orange: 5,
              yellow: 5, 
            },
          },
          ham: { 
            chanceWeight: 1000,
            energy: {
              red: 15,
              orange: 5,
            },
          },
          fish: { 
            chanceWeight: 1000,
            energy: {
              red: 15,
              blue: 5,
            },
          },
          chicken: { 
            chanceWeight: 1000,
            energy: {
              red: 15,
              yellow: 5,
            },
          },
          egg: { 
            chanceWeight: 300,
            energy: {
              red: 5,
              yellow: 5,
              blue: 5, 
              violet: 5,
            },
          },
          copperEgg: { 
            chanceWeight: 20,
            energy: {
              copper: 20,
            },
          },
          silverEgg: { 
            chanceWeight: 20,
            energy: {
              silver: 20,
            },
          },
          goldEgg: { 
            chanceWeight: 20,
            energy: {
              gold: 20,
            },
          },
          diamondEgg: { 
            chanceWeight: 1,
            energy: {
              diamond: 20,
            },
          },
          bread: { 
            chanceWeight: 2000,
            energy: {
              red: 5,
              orange: 15,
            },
          },
          rice: { 
            chanceWeight: 2000,
            energy: {
              orange: 10,
              green: 10,
            },
          },
          sushiRoll: { 
            chanceWeight: 200,
            energy: {
              red: 5,
              orange: 5,
              green: 5,
              blue: 5,
            },
          },
          oats: { 
            chanceWeight: 2000,
            energy: {
              red: 5,
              orange: 10,
              yellow: 5,
            },
          },
          cheese: { 
            chanceWeight: 500,
            energy: {
              yellow: 10,
              indigo: 10,
            },
          },
          milk: { 
            chanceWeight: 500,
            energy: {
              red: 5,
              indigo: 15,
            },
          },
          apple: { 
            chanceWeight: 500,
            energy: {
              red: 10,
              yellow: 10,
            },
          },
          banana: { 
            chanceWeight: 500,
            energy: {
              orange: 5,
              yellow: 15,
            },
          },
          brocolli: { 
            chanceWeight: 500,
            energy: {
              yellow: 5,
              green: 15,
            },
          },
          coconut: { 
            chanceWeight: 500,
            energy: {
              yellow: 5,
              orange: 5,
              green: 5,
              cyan: 5,
            },
          },
          spinach: { 
            chanceWeight: 500,
            energy: {
              red: 5,
              green: 15,
            },
          },
          cherry: { 
            chanceWeight: 500,
            energy: {
              red: 10, 
              orange: 5,
              yellow: 5,
            },
          },
          watermelon: { 
            chanceWeight: 500,
            energy: {
              red: 10, 
              yellow: 5,
              green: 5,
            },
          },
          carrot: { 
            chanceWeight: 500,
            energy: {
              orange: 15,
              green: 5,
            },
          },
          orange: { 
            chanceWeight: 500,
            energy: {
              orange: 15,
              yellow: 5,
            },
          },
          mango: { 
            chanceWeight: 500,
            energy: {
              yellow: 20,
            },
          },
          grapes: { 
            chanceWeight: 500,
            energy: {
              yellow: 5,
              green: 10,
              violet: 5,
            },
          },
          strawberries: { 
            chanceWeight: 500,
            energy: {
              red: 15,
              yellow: 5,
            },
          },
          tomato: { 
            chanceWeight: 500,
            energy: {
              red: 10,
              orange: 5,
              yellow: 5,
            },
          },
          eggplant: { 
            chanceWeight: 500,
            energy: {
              red: 5,
              green: 5,
              violet: 10,
            },
          },
          blueberries: { 
            chanceWeight: 500,
            energy: {
              yellow: 5,
              blue: 15,
            },
          },
          pizza: { 
            chanceWeight: 500,
            energy: {
              red: 3,
              orange: 3,
              yellow: 3,
              green: 3,
              cyan: 2, 
              blue: 2,
              indigo: 2,
              violet: 2,
            },
          },
          chocolate: { 
            chanceWeight: 500,
            energy: {
              black: 10,
              willpower: 10,
            },
          },
        },
      },
    },
  },

  // this will become mutable once cloned
  backModel: {
    actor: [],
    seed: 'test',
    randomizers: {
      awakening: null,
      level: null,
      item: null,
    },
    levelCaveGenerator: {
      openness: 0.3,
      //openness: 0.2,
      wallThreshold: 0.5,
      requireSurroundingWalls: 2,
    },
    levelSize: new Pair(50, 50),
    level: [],
    // null means it's already been picked up 
    experiencePotionInLevel: null, 
    glowGrid: [],
    gameClock: 0,
    creatorMode: false,
    sounds: [],
    smellIndexes: [], // of smell, index aligns with smells array
    smellCellCounts: [], // total number of cells which have this smell
    smells: [],      // [smell index][x][y] = amount
    // populated when game is initialized
    heat: [],        // [x][y] = heat
    player: { 
      base: {
        showAs: '🙂', 
        name: 'player', 
      },
      pos: emptyPair, 
      gold: 0,
      level: 0,
      awakenedPools: [],
      species: null,
      focus: null,
      medDepth: 0,
      memory: {
        sight: [],
        sound: [],
        smell: [],
        feel: [],
        energy: [],
      },
      equip: {
        hand: [],
        ring: [],
        amulet: null,
        head: null, // helmet or hat
        face: null, // glasses or mask
        body: null,
        cloak: null,
        gloves: null,
        boots: null,
        book: null, // book currently being studied
      },
      inventory: {
        armor: [],
        book: [],
        food: [],
        jewelry: [],
        wand: [],
        potion: [],
        rock: [],
        scroll: [],
        weapon: [],
        tool: [],
      },
      poolCurrentPast: [], // previous value of poolCurrent
      poolCurrent: [],     // integers of how much is in each pool
      poolMaxPast: [],     // previous value of poolMax
      poolMax: [],         // integers of how big each pool is
      poolDigits: 3,       // number of digits needed to represent all pools
      channelCurrent: [],  // integers of openness of each channel
      channelMax: [],      // integers of max value of each channel
      // filled in during initialization
      growth: {
        attributes: { },
        poolCapacity: { },
        energyEfficiency: { },
        channelMaxFlow: { },
        skills: { },
      },
      // this is filled in during initialization
      growthSelection: { },
    },
  },

  // this will become mutable once cloned
  frontModel: {

    currentScreen: 'main',
    currentKeyMode: 'base',
    motionMode: 'attackOrMove',

    levelCellsChanged: [],
    levelChanged: false,
    messages: [],
    messagesHeader: 1,
    messagesChanged: false,
    statusChanged: false,
    statusMode: 'expanded',

    selectAction: null,
    selectExecute: null,
    selectAllowMultiple: true,
    selectCount: null,
    selectCountList: [],
    selectCountMaxList: [],
    selectCountMax: null,

    // either an array or an object, 
    // with values being booleans
    // each representing whether an
    // option is selected or not
    selectFlags: null,

    selectKeys: [], 
    selectMultiple: false,
    selectNameList: [],
    selectSubjectList: [],

    // a function which takes in (selectMultiple, selectFlags)
    // and returns a string representing the title
    selectTitle: null, 

    selectMaxWidth: null,
    selectMeta: {},

    target: {
      screen: null,
      window: null,
      pos: null,
    },

  },
}

// immutable after initialization
const screens = {

  main: {

    cellPixelDimensions: new Pair(26, 30),
    size: new Pair(55, 18),

    window: {

      // smallCellSize is added to each of these
      status: {
        pos: emptyPair,
        size: new Pair(15, 19),
        offset: new Pair(7, 2),
        cellPixelDimensions: new Pair(8.4, 16),
        fontStyle: fontStyle.compact,
      },

      level: {
        pos: new Pair(15, 0),
        size: new Pair(31, 19),
        cellPixelDimensions: new Pair(26, 30),
        fontStyle: fontStyle.fixed,
        panCellOffset: emptyPair,
      },

      message: {
        pos: new Pair(46, 0),
        size: new Pair(17, 19),
        offset: new Pair(5, 2),
        cellPixelDimensions: new Pair(8.4, 16),
        fontStyle: fontStyle.compact,
      },

    },

  },

}
  
// immutable
const keyMap = {
  base: {
    moveLeft: [ 'h', 'ArrowLeft' ],
    moveRight: [ 'l', 'ArrowRight' ],
    moveUp: [ 'k', 'ArrowUp' ],
    moveDown: [ 'j', 'ArrowDown' ],
    moveLeftUp: [ 'y' ],
    moveLeftDown: [ 'b' ],
    moveRightUp: [ 'u' ],
    moveRightDown: [ 'n' ],
    wait: [ '.' ],
    setMotionModeAttackOrMove: [ 'A' ],
    setMotionModeAttack: [ 'a' ],
    setMotionModeMove: [ 'M' ],
    enterTargetMode: [ 'x' ],
    pickUpItem: [ ',' ],
    showInventory: [ 'i' ],
    showEquipment: [ 'e' ],
    enterCreatorMode: [ 'C' ],
    creatorModeCommand: [ '`' ],
    channelCommand: [ 'c' ],
    changeStatusMode: [ 's' ],
    willpowerFocus: [ 'f' ],
    helpMode: [ '?' ],
    editGrowthAllocation: [ 'g' ],
  },
  target: {
    moveLeft: [ 'h', 'ArrowLeft' ],
    moveRight: [ 'l', 'ArrowRight' ],
    moveUp: [ 'k', 'ArrowUp' ],
    moveDown: [ 'j', 'ArrowDown' ],
    moveLeftFast: [ 'H' ],
    moveRightFast: [ 'L' ],
    moveUpFast: [ 'K' ],
    moveDownFast: [ 'J' ],
    moveLeftUp: [ 'y' ],
    moveLeftDown: [ 'b' ],
    moveRightUp: [ 'u' ],
    moveRightDown: [ 'n' ],
    creatorCreateTarget: [ 'c' ],
    creatorDeleteTarget: [ 'd' ],
    creatorTeleportToTarget: [ 't' ],
    exitTargetMode: [ 'Escape' ],
    enterTargetMode: [],
  },
  creator: {
    exitSimple: [ 'Escape' ],
    creatorRegenLevel: [ 'r' ],
    creatorSetEnergy: [ 'e' ],
    creatorSetSkill: [ 's' ],
    creatorAdvanceLevel: [ 'x' ],
    creatorAwakenPool: [ 'a' ],
  },
  select: {
    exitSimple: [ 'Escape' ],
    executeSelectAction: [ 'Enter' ],
    invertSelectedItems: [ '/' ],
    invertMultiSelect: [ ',' ],
    clearNumericSelection: [ 'Backspace' ],
    selectItem: [],
  },
}

// immutable
const commandExecution = {
  moveLeft: () => {
    topController.playerMotionRelative(new Pair(-1, 0))
  },
  moveRight: () => {
    topController.playerMotionRelative(new Pair(1, 0))
  },
  moveUp: () => {
    topController.playerMotionRelative(new Pair(0, -1))
  },
  moveDown: () => {
    topController.playerMotionRelative(new Pair(0, 1))
  },
  moveLeftFast: () => {
    topController.playerMotionRelative(new Pair(-10, 0))
  },
  moveRightFast: () => {
    topController.playerMotionRelative(new Pair(10, 0))
  },
  moveUpFast: () => {
    topController.playerMotionRelative(new Pair(0, -10))
  },
  moveDownFast: () => {
    topController.playerMotionRelative(new Pair(0, 10))
  },
  moveLeftUp: () => {
    topController.playerMotionRelative(new Pair(-1, -1))
  },
  moveRightUp: () => {
    topController.playerMotionRelative(new Pair(1, -1))
  },
  moveLeftDown: () => {
    topController.playerMotionRelative(new Pair(-1, 1))
  },
  moveRightDown: () => {
    topController.playerMotionRelative(new Pair(1, 1))
  },
  wait: () => {
    topController.wait()
  },
  setMotionModeMove: () => {
    topController.setMotionMode('move')
  },
  setMotionModeAttack: () => {
    topController.setMotionMode('attack')
  },
  setMotionModeAttackOrMove: () => {
    topController.setMotionMode('attackOrMove')
  },
  enterTargetMode: () => {
    topController.enterTargetMode()
  },
  exitTargetMode: () => {
    topController.setKeyMode('base')
  },
  pickUpItem: () => {
    topController.pickUpItem()
  },
  showInventory: () => {
    topController.showInventory()
  },
  showEquipment: () => {
    topController.showEquipment()
  },
  executeAction: (key) => {
    topController.executeAction(key)
  },
  exitSimple: () => {
    topController.exitSimple()
  },
  selectItem: (key) => {
    topController.selectItem(key)
  },
  executeSelectAction: () => {
    topController.executeSelectAction()
  },
  invertSelectedItems: () => {
    topController.invertSelectedItems()
  },
  invertMultiSelect: () => {
    topController.invertMultiSelect()
  },
  clearNumericSelection: () => {
    topController.clearNumericSelection()
  },
  enterCreatorMode: () => {
    topController.enterCreatorMode()
  },
  creatorDeleteTarget: () => {
    topController.creatorModeDeleteTarget()
  },
  creatorCreateTarget: () => {
    topController.creatorModeCreateTarget()
  },
  creatorTeleportToTarget: () => {
    topController.creatorModeTeleportToTarget()
  },
  creatorRegenLevel: () => {
    topController.creatorModeRegenLevel()
  },
  creatorSetEnergy: () => {
    topController.creatorModeSetEnergy()
  },
  creatorSetSkill: () => {
    topController.creatorModeSetSkill()
  },
  creatorAdvanceLevel: () => {
    topController.creatorModeAdvanceLevel()
  },
  creatorAwakenPool: () => {
    topController.creatorModeAwakenPool()
  },
  creatorModeCommand: () => {
    topController.creatorModeCommand()
  },
  channelCommand: () => {
    topController.channelCommandSelectPoolType()
  },
  changeStatusMode: () => {
    topController.changeStatusMode()
  },
  willpowerFocus: () => {
    topController.willpowerFocus()
  },
  editGrowthAllocation: () => {
    topController.editGrowthAllocation()
  },
}

function random(possibilities) {
  return Math.floor(Math.random() * possibilities)
}

class SeededRandomizer {
  constructor(seed) {
    this.generator = new Math.seedrandom(seed)
    this.current = this.next()
  }

  next(possibilities = 0) {
    this.current = this.generator()
    if(possibilities == 0) {
      return this.current
    } else {
      return Math.floor(this.current * possibilities)
    }
  }

  fork() {
    return new SeededRandomizer(this.current)
  }
}

function debug(message) {
  console.log(message)
}

function warn(message) {
  console.log(message)
}

function err(message) {
  throw new Error(message)
}

class TopController {

  constructor() {
    this.frontController = new FrontController()
    this.backController = new BackController(this.frontController.addMessage)
    this.refresh()
  }

  getAttribute(actor, key, boost) {
    return this.backController.getAttribute(actor, key, boost)
  }

  getSkill(actor, key, boost) {
    return this.backController.getSkill(actor, key, boost)
  }

  drinkPotion(item, count) {
    const fc = this.frontController
    const bc = this.backController
    let success
    for(let i = 0; i < count; i++) {
      if(item.base.name == 'experience') {
        fc.setSelectMeta('item', item)
        success = this.drinkExperiencePotion()
      } else {
        err("Unknown potion: " + getNameOf(null, item))
      }
      if(!success) break
    }
  }

  drinkExperiencePotion() {
    const fc = this.frontController
    const bc = this.backController
    const player = bc.getPlayer()
    const [selected, _] = getGrowthSelectCount(
      bc.getGrowthSelection()
    )
    const total = bc.getGrowthPerLevel()
    let success = false
    if(!bc.getCreatorMode() && selected < total) {
      fc.addMessage("You must use all of your growth points.")
    } else if(!bc.getCreatorMode() && selected > total) {
      fc.addMessage("You have used too many growth points.")
      fc.addMessage("Reduce your selections and try again.")
    } else {
      bc.addGrowthSelectionToGrowth()
      bc.fillEnergy(player, poolTypes.interna)
      const item = fc.getSelectMeta('item')
      if(item) {
        bc.removeItemFromInventory(item, 1)
        fc.addMessage("Drank " + getNameOf(1, item))
        fc.addMessage("You feel more experienced.")
        fc.clearSelectMeta()
      }
      player.level++
      if(
        player.species.poolAwakeningLevels.some(
          x => x == player.level
        )
      ) {
        this.poolAwakening()
      }
      fc.setStatusChanged(true)
      success = true
    }
    this.exitSimple()
    return success
  }

  poolAwakening() {

    const fc = this.frontController
    const bc = this.backController
    const player = bc.getPlayer()
    let possiblePools = Object.values(pools)

    // don't awaken the same pool twice
    // don't awaken interna
    possiblePools = possiblePools.filter(pool => {
      if(
        player.awakenedPools.find(x => x == pool)
        || pool.type == poolTypes.interna
      ) {
        return false
      }
      return true
    })

    const spectra = possiblePools.filter(pool => 
      pool.type == poolTypes.spectra
    )

    const etherea = possiblePools.filter(pool => 
      pool.type == poolTypes.etherea
    )

    const lumina = possiblePools.filter(pool => 
      pool.type == poolTypes.lumina
    )

    const exotica = possiblePools.filter(pool => 
      pool.type == poolTypes.exotica
    )

    const randomizer = bc.getRandomizer('awakening')

    let choice

    if(randomizer.next(4) > 0 && spectra.length) {
      choice = spectra[randomizer.next(spectra.length)]
    } else if(randomizer.next(4) > 0 && etherea.length) {
      choice = etherea[randomizer.next(etherea.length)]
    } else if(randomizer.next(4) > 0 && lumina.length) {
      choice = lumina[randomizer.next(lumina.length)]
    } else if(randomizer.next(4) > 0 && exotica.length) {
      choice = exotica[randomizer.next(exotica.length)]
    } else if(possiblePools.length) {
      choice = possiblePools[randomizer.next(possiblePools.length)]
    } else {
      fc.addMessage("Awakening failed, no pools available")
    }

    if(choice) {
      player.awakenedPools.push(choice)
      fc.addMessage(
        "You have awakened the "
        + choice.longName 
        + " energy pool."
      )
      bc.fillPool(player, choice)
      fc.setStatusChanged(true)
    }

  }

  editGrowthAllocationSelect() {
    this.frontController.editGrowthAllocationSelect()
  }

  editGrowthAllocationSelectSomething(
    title,
    growthKey,
    getAttributeFunction,
  ) {

    const fc = this.frontController
    const bc = this.backController
    const player = bc.getPlayer()
    const growthSelection = bc.getGrowthSelection()
    const growthPerLevel = bc.getGrowthPerLevel()
    
    fc.resetSelect()
    fc.setSelectTitle(
      () => {
        const [growthSelectCount] = 
          getGrowthSelectCount(growthSelection)
        const selectedString = 
          '(' 
        + growthSelectCount 
        + '/' 
        + growthPerLevel 
        + ' growth points used)'
        return 'Choose ' + title + ': ' + selectedString
      }
    )

    let names = []

    for(let attribute in growthSelection[growthKey]) {
      let extra = ' (' 
        + getAttributeFunction(player, attribute, 0)
        + ' → '
        + getAttributeFunction(player, attribute, 1)
        + ')'
      names.push(attribute + extra)
    }

    fc.setSelectMultiple(true)
    fc.setSelectFlags(growthSelection[growthKey])
    fc.setSelectNameList(names)
    fc.setKeyMode('select')

    fc.setSelectExecute(() => {
      topController.editGrowthAllocation()
    })

    fc.showSelectedItems()

  }

  editGrowthAllocationSelectAttributes() {
    this.editGrowthAllocationSelectSomething(
      'attributes',
      'attributes',
      (actor, key, boost) => topController.getAttribute(actor, key, boost),
    )
  }

  editGrowthAllocationSelectPoolCapacity() {
    this.editGrowthAllocationSelectSomething(
      'pool capacity',
      'poolCapacity',
      (actor, key, boost) => getPoolMax(actor, key, boost),
    )
  }

  editGrowthAllocationSelectEnergyEfficiency() {
    this.editGrowthAllocationSelectSomething(
      'energy efficiency',
      'energyEfficiency',
      (actor, key, boost) => getEnergyEfficiency(actor, key, boost),
    )
  }

  editGrowthAllocationSelectChannelMaxFlow() {
    this.editGrowthAllocationSelectSomething(
      'channel max flow',
      'channelMaxFlow',
      (actor, key, boost) => getChannelMaxFlow(actor, key, boost),
    )
  }

  editGrowthAllocationSelectSkills() {
    this.editGrowthAllocationSelectSomething(
      'skills',
      'skills',
      (actor, key, boost) => topController.getSkill(actor, key, boost),
    )
  }

  wait() {
    const fc = this.frontController
    const bc = this.backController
    const player = bc.getPlayer()
    const rate = bc.getMeditationRate(player)
    if(player.focus) {
      if(player.medDepth == 0) {
        player.medDepth = 0.1
      } else {
        player.medDepth *= rate
      }
    }
    const maxDepth = bc.getMaxMeditationDepth(player)
    if(player.medDepth > maxDepth) player.medDepth = maxDepth
    fc.setStatusChanged(true)
    topController.advanceTime(false)
  }

  enterTargetMode() {
    this.setKeyMode('target')
    if(!this.frontController.getTarget().pos) {
      this.setTarget(this.getPlayerPos())
    } else {
      this.outputTargetMessages()
    }
  }

  afterEachTurn() {
    const fc = this.frontController
    const bc = this.backController
    const player = bc.getPlayer()
    if(player.medDepth && didSomething) {
      player.medDepth = 0
      fc.setStatusChanged(true)
    }
    topController.update()
  }

  beforeEachTurn() {
    this.clearMessages()
    const player = this.backController.getPlayer()
    player.poolCurrentPast = [ ...player.poolCurrent ]
    player.poolMaxPast = [ ...player.poolMax ]
    didSomething = false
  }

  editGrowthAllocation() {
    const fc = this.frontController
    const bc = this.backController
    fc.editGrowthAllocationSelectCategory(
      bc.getGrowthSelection(),
      bc.getGrowthPerLevel(),
    )
  }

  willpowerFocus() {
    const fc = this.frontController
    fc.willpowerFocusSelectFocusType()
    const bc = this.backController
    const player = bc.getPlayer()
    player.focus = null
    player.medDepth = 0
    fc.setStatusChanged(true)
  }

  willpowerFocusSelectPool() {
    this.frontController.willpowerFocusSelectPool()
  }

  willpowerFocusExecute() {
    const fc = this.frontController
    const bc = this.backController
    const player = bc.getPlayer()
    const selectedSubject = fc.getSelectedSubject()
    player.focus = selectedSubject
    fc.setStatusChanged(true)
    this.exitSimple()
  }

  afterWillpowerFocusSelectFocusType() {
    const fc = this.frontController
    const key = fc.getSelectedKeys()[0]
    if(key === 'p') {
      fc.willpowerFocusSelectPoolType()
    } else if(key === 's') {
      fc.willpowerFocusSelectSense()
    } else {
      err('Invalid key ' + key)
    }
  }

  changeStatusMode() {
    this.frontController.changeStatusMode()
  }
  
  channelCommandSelectPoolType() {
    this.frontController.channelCommandSelectPoolType()
  }
  
  channelCommandSelectPool() {
    this.frontController.channelCommandSelectPool()
  }

  channelCommandSelectChannel() {

    const bc = this.backController
    const fc = this.frontController
    let names = []
    let subjects = []

    let pools = fc.getSelectedSubjects()

    if(pools.length == 0) {
      err("No pools selected. This shouldn't happen")
    }

    for(let p = 0; p < pools.length; p++) {

      const pool = pools[p]

      for(let c = 0; c < pool.channelIndexes.length; c++) {

        const channelIndex = pool.channelIndexes[c]
        if(!subjects.includes(channelIndex)) {

          const channel = poolChannels[channelIndex]
          let name = []

          for(let f = 0; f < channel.from.length; f++) {
            const from = channel.from[f]
            for(let t = 0; t < channel.to.length; t++) {
              const to = channel.to[t]
              const channelString = getChannelString(
                bc.getPlayer(), 
                from, 
                to,
              )
              name.push(channelString)
            }
          }

          names.push(name)
          subjects.push(channelIndex)

        }

      }

    }

    fc.resetSelect()

    fc.setSelectTitle(
      (multi) => { 
        if(multi) {
          return 'Choose channels:'
        } else {
          return 'Choose channel:'
        }
      }
    )

    fc.setSelectNameList(names)
    fc.setSelectSubjectList(subjects)
    fc.setSelectAllowMultiple(true)
    fc.setSelectMaxWidth(screens.main.window.message.smallCellSize.x / 2)
    this.setKeyMode('select')

    fc.setSelectAction(
      () => { topController.channelCommandSelectFlow() }
    )

    fc.showSelectedItems()

  }

  channelCommandSelectFlow() {
    this.frontController.channelCommandSelectFlow()
  }

  channelCommandExecuteChange() {
    const bc = this.backController
    const fc = this.frontController
    const player = bc.getPlayer()
    const selectedIndex = fc.getSelectedIndex()
    if(selectedIndex == -1) err("No flow selected")
    const flow = 9 - selectedIndex
    for(let channelIndex of fc.getSelectMeta('channelIndexes')) {
      bc.setChannelFlow(player, channelIndex, flow)
    }
    fc.setStatusChanged(true)
    this.exitSimple()
  }

  creatorModeCommand() {
    const bc = this.backController
    const fc = this.frontController
    if(!bc.getCreatorMode()) {
      fc.addMessage('Invalid command.')
    } else {
      this.setKeyMode('creator')
      fc.outputCreatorModeMessages()
    }
  }

  creatorModeCreateTarget() {
    const bc = this.backController
    const fc = this.frontController
    if(!bc.getCreatorMode()) {
      fc.addMessage('Invalid command.')
    } else {
      const target = fc.getTarget().pos
      this.handleCreateTarget(target, template.generated)
      this.setKeyMode('select')
    }
  }

  handleCreateTarget(target, template) {

    const bc = this.backController
    const fc = this.frontController
    let count = 1 

    if(!target) {

      let [subjects, counts] = fc.getSelectedSubjectsAndCounts()
      let found = subjects[0]
      count = counts[0]

      if(found) {
        target = found.target
        template = found.template
      } else {
        err("No subjects were selected.")
      }
      
    }

    if(!template.sub) {

      const countedItem = { base: template }
      countedItem.count = count
      bc.addSubjectToLevel(countedItem, target)
      fc.setLevelChanged(true)
      fc.addMessage('Created ' + getNameOf(count, countedItem))
      this.setKeyMode('target')
      fc.setTarget(target)
      this.outputTargetMessages()

    } else {

      let subjects = []
      let names = []

      for(let [key, value] of Object.entries(template.sub)) {
        let newTemplate = template.sub[key]
        names.push(key)
        subjects.push({
          target: target,
          template: newTemplate,
        })
      }

      fc.resetSelect()
      fc.setSelectAllowMultiple(false)
      fc.setSelectNameList(names)
      fc.setSelectSubjectList(subjects)
      fc.setSelectTitle(() => 'Choose something to create:')
      fc.setSelectCountMax(999)

      fc.setSelectAction(
        () => { topController.handleCreateTarget() }
      )

      fc.showSelectedItems()

    }

  }

  creatorModeDeleteTarget() {
    const bc = this.backController
    const fc = this.frontController
    if(!bc.getCreatorMode()) {
      fc.addMessage('Invalid command.')
    } else {
      const target = fc.getTarget().pos
      const cell = bc.getCell(target)
      let subject
      if(cell.occupiedBy) {
        fc.addMessage('Deleted ' + getNameOf(null, cell.occupiedBy))
        subject = cell.occupiedBy
      } else if(cell.onFloor.length > 0) {
        fc.addMessage('Deleted ' + getNameOf(null, cell.onFloor[0]))
        subject = cell.onFloor[0]
      } else {
        fc.addMessage('There\'s nothing here to delete.')
      }
      if(subject) {
        bc.removeSubjectFromLevel(subject, target)
        fc.setLevelChanged(true)
      }
      this.outputTargetMessages()
    } 
  }

  creatorModeRegenLevel() {
    const bc = this.backController
    const fc = this.frontController
    if(!bc.getCreatorMode()) {
      fc.addMessage('Invalid command.')
    } else {
      bc.buildLevel()
      fc.setLevelChanged(true)
    } 
    this.exitSimple()
  }

  creatorModeSetEnergy() {
    const bc = this.backController
    const fc = this.frontController
    if(!bc.getCreatorMode()) {
      fc.addMessage('Invalid command.')
    } else {
      fc.selectPoolType(
        () => { topController.creatorModeSetEnergySelectPool() },
        true,
      )
    } 
  }

  creatorModeSetSkill() {
    const bc = this.backController
    const fc = this.frontController
    if(!bc.getCreatorMode()) {
      fc.addMessage('Invalid command.')
    } else {
      fc.selectSkill(
        () => { topController.creatorModeSetSkillSelectSkill() },
        true,
      )
    } 
  }

  creatorModeSetSkillSelectSkill() {
    const bc = this.backController
    const fc = this.frontController
    const player = bc.getPlayer()
    const skill = fc.getSelectedSubject()
    const count = fc.getSelectCount() || 0
    bc.setSkill(player, skill.name, count)
    fc.addMessage('Skill ' + skill.name + ' set to ' + count)
    fc.setStatusChanged(true)
    this.exitSimple()
  }

  creatorModeSetEnergySelectPool() {
    this.frontController.creatorModeSetEnergySelectPool()
  }

  creatorModeSetEnergyGetAmount() {
    this.frontController.creatorModeSetEnergyGetAmount()
  }

  creatorModeSetEnergyExecute() {
    const bc = this.backController
    const fc = this.frontController
    const player = bc.getPlayer()
    const pools = fc.getSelectMeta('subjects')
    const selectedSubject = fc.getSelectedSubject()
    const selectCount = fc.getSelectCount()
    for(const pool of pools) {
      let amount = selectCount
      let max = getPoolMax(player, pool.name)
      if(selectedSubject) {
        amount = max * selectedSubject
      }
      bc.setPool(player, pool, amount)
    }
    fc.setStatusChanged(true)
    this.exitSimple()
  }

  creatorModeAwakenPool() {
    const bc = this.backController
    const fc = this.frontController
    if(!bc.getCreatorMode()) {
      fc.addMessage('Invalid command.')
    } else {
      this.poolAwakening()
      this.exitSimple()
    } 
  }

  creatorModeAdvanceLevel() {
    const bc = this.backController
    const fc = this.frontController
    if(!bc.getCreatorMode()) {
      fc.addMessage('Invalid command.')
    } else {
      this.drinkExperiencePotion()
    } 
  }

  creatorModeTeleportToTarget() {
    const bc = this.backController
    const fc = this.frontController
    if(!bc.getCreatorMode()) {
      fc.addMessage('Invalid command.')
    } else {
      const target = fc.getTarget().pos
      const player = bc.getPlayer()
      this.occupantMove(player, target)
    } 
  }

  enterCreatorMode() {
    this.backController.setCreatorMode()
    this.frontController.setStatusChanged(true)
  }

  getFloorItemsAtPlayerPos() {
    const bc = this.backController
    const playerPos = bc.getPlayerPos()
    const floorItems = bc.getFloorItemsAt(playerPos)
    return floorItems 
  }

  selectItem(key) {
    this.frontController.selectItem(key)
  }

  exitSimple() {
    const fc = this.frontController
    this.setKeyMode('base')
    // this causes problems when one select joins to another
    // fc.resetSelect()
    fc.setStatusChanged(true)
  }

  executeAction(key) {
    this.exitSimple()
    this.frontController.executeAction(key)
  }

  showInventoryActions() {
    this.frontController.showInventoryActions()
  }

  showInventoryGroup() {

    const bc = this.backController
    const fc = this.frontController

    const selectedInventoryType = fc.getSelectedSubject()

    if(selectedInventoryType) {
      const inventoryGroup = bc.getInventoryGroup(
        selectedInventoryType
      )
      fc.showInventoryGroup(inventoryGroup)
    } else {
      fc.addMessage("Invalid inventory type.")
      this.showInventory()
    }

  }

  showEquipment() {

    const bc = this.backController
    const fc = this.frontController

    const equip = bc.getEquipment()
    const hands = bc.getPlayerSpecies().hands

    let names = []
    let subjects = []
    const tab = 8
    for(let [type, value] of Object.entries(equip)) {

      if(type == 'hand' || type == 'ring') {

        for(let j = 0; j < hands; j++) {

          let name = '(empty)'

          if(value[j]) {
            name = getNameOf(null, value[j]) 
          }

          const out = type + ' ' + (j+1)
          names.push(out.padEnd(tab) + ' ' + name)
          subjects.push(value[j])

        }

      } else {

        let name = '(empty)'

        if(value) {
          name = getNameOf(null, value) 
        }

        names.push(type.padEnd(tab) + ' ' + name)
        subjects.push(value)

      }

    }

    this.setKeyMode('select')
    fc.resetSelect()
    fc.setSelectNameList(names)

    fc.setSelectTitle(
      (multi) => {
        if(multi) return 'Choose some equipped items:'
        return 'Choose an equipped item:'
      }
    )

    fc.setSelectAction(
      () => { topController.showInventoryActions() }
    )

    fc.setSelectSubjectList(subjects)
    fc.showSelectedItems()

  }

  showInventory() {

    const bc = this.backController
    const fc = this.frontController
    let noItemsFound = true
    let names = []
    let subjects = []
    let keys = []

    for(let key in inventoryTypes) {
      const type = inventoryTypes[key]
      const group = bc.getInventoryGroup(type)
      if(group.length > 0) {
        if(noItemsFound) {
          noItemsFound = false
        }
        names.push(type + ' (' + group.length + ' items)')
        subjects.push(type)
        keys.push(key)
      }
    }

    if(noItemsFound) {

      fc.addMessage("You aren't carrying anything.")
      this.exitSimple()

    } else {

      fc.resetSelect()
      fc.setSelectNameList(names)
      fc.setSelectKeys(keys)
      this.setKeyMode('select')
      fc.setSelectAllowMultiple(false)
      fc.setSelectTitle(() => 'Choose an inventory type:')

      fc.setSelectAction(
        () => { topController.showInventoryGroup() }
      )

      fc.setSelectSubjectList(subjects)
      fc.showSelectedItems()

    }

  }

  executeSelectAction() {
    const fc = this.frontController
    let executeAction = fc.getSelectExecute()
    let selectAction = fc.getSelectAction()
    if(fc.getSelectedIndex() >= 0) {
      if(selectAction) {
        selectAction()
      } else if(executeAction) {
        executeAction()
      } else {
        err("No select action defined.")
      }
    } else if(executeAction) {
      executeAction()
    } else {
      fc.showSelectedItems()
    }
  }

  clearNumericSelection() {
    this.frontController.clearNumericSelection()
  }

  invertMultiSelect() {
    const fc = this.frontController
    if(fc.getSelectAllowMultiple()) {
      fc.invertMultiSelect()
      fc.showSelectedItems()
    } else {
      fc.addMessage("Multi-select not allowed here")
      fc.showSelectedItems()
    }
  }

  invertSelectedItems() {
    const fc = this.frontController
    fc.invertSelectedItems()
    fc.showSelectedItems()
  }

  pickUpSelectedItems() {

    const bc = this.backController
    const fc = this.frontController
    const playerPos = bc.getPlayerPos()
    const floorItems = bc.getFloorItemsAt(playerPos)

    let count = 0

    let selectedFloorItems = []
    let selectedCounts = []

    for(let i = 0; i < floorItems.length; i++) {

      if(fc.isIndexSelected(i)) {

        let selectCount = fc.getSelectCountByIndex(i) || 1
        count += selectCount
        selectedFloorItems.push(floorItems[i])
        selectedCounts.push(selectCount)

      }

    }

    for(let i = 0; i < selectedFloorItems.length; i++) {

      let item = selectedFloorItems[i]
      let selectCount = selectedCounts[i]
      item = bc.removeSubjectFromLevel(
        item,
        playerPos,
        selectCount,
      )
      bc.addItemToInventory(item)

    }

    if(count > 0) {
      fc.setStatusChanged(true)
      fc.addMessage('Picked up ' + count + ' items.')
    }

    this.exitSimple()
    
  }

  pickUpItem() {

    const bc = this.backController
    const fc = this.frontController
    const playerPos = bc.getPlayerPos()
    const floorItems = bc.getFloorItemsAt(playerPos)

    if(floorItems.length == 0) {
      fc.addMessage("There's nothing here to pick up.")
      return
    }

    if(floorItems.length == 1) {
      const item = bc.removeSubjectFromLevel(
        floorItems[0],
        playerPos, 
      )
      bc.addItemToInventory(item)
      fc.setStatusChanged(true)
      fc.addMessage('Picked up ' + getNameOf(item.count, item) + '.')
    } else {
      const floorItems = this.getFloorItemsAtPlayerPos()

      fc.resetSelect()
      fc.setSelectNameList(
        floorItems.map(
          item => getNameOf(null, item)
        )
      )

      this.setKeyMode('select')
      fc.setSelectMultiple(true)

      fc.setSelectTitle(
        (multi) => { 
          if (multi) return 'Choose items to pick up:'
          return 'Choose item to pick up:'
        }
      )

      fc.setSelectAction(
        () => { topController.pickUpSelectedItems() }
      )

      fc.setSelectCountMaxList(
        floorItems.map(
          item => item.count
        )
      )
      
      fc.showSelectedItems()
    }

  }

  eatItem(item, count) {

    const bc = this.backController
    const fc = this.frontController
    const player = bc.getPlayer()

    if(item.base.type != 'food') { 
      err('Not food: ' + getNameOf(null, item))
    }

    if(item.base.energy) {
      for(let [energyType, amount] of Object.entries(item.base.energy)) {
        bc.addEnergy(player, energyType, amount * count)
      }
      fc.setStatusChanged(true)
    }

    fc.addMessage("Ate " + getNameOf(count, item))

    bc.removeItemFromInventory(item, count)

  }

  equipItem(item) {

    const bc = this.backController
    const fc = this.frontController
    const group = bc.getInventoryGroup(item.base.type)
    let index = null

    for(let i = 0; i < group.length; i++) {
      if(group[i] == item) {
        index = i
        break
      }
    }

    const name = getNameOf(null, item)
    if(index != null) {
      if(bc.isEquipped(item)) {
        fc.addMessage(
          name + ' is already equipped.'
        )
      } else if(
        item.base.hands 
        && bc.getPlayerSpecies().hands < item.base.hands
      ) {
        fc.addMessage('You don\'t have enough hands to equip that')
      } else {
        let result = bc.equipItem(item)
        if(result) {
          fc.addMessage('Equipped ' + name + '.')
        } else {
          fc.addMessage('Failed to equip ' + name + '.')
        }
      }
    }

  }

  unequipItem(item) {

    const bc = this.backController
    const fc = this.frontController
    const group = bc.getInventoryGroup(item.base.type)
    let index = null

    for(let i = 0; i < group.length; i++) {
      if(group[i] == item) {
        index = i
        break
      }
    }

    const name = getNameOf(null, item)

    if(index != null) {
      if(!bc.isEquipped(item)) {
        fc.addMessage(
          name + ' is not equipped.'
        )
      } else {
        let result = bc.unequipItem(item)
        if(result) {
          fc.addMessage('Unequipped ' + name + '.')
        } else {
          fc.addMessage('Failed to unequip ' + name + '.')
        }
      }
    }

  }

  dropItem(item, count) {
    const bc = this.backController
    const fc = this.frontController
    const group = bc.getInventoryGroup(item.base.type)
    let index = null
    for(let i = 0; i < group.length; i++) {
      if(group[i] == item) {
        index = i
        break
      }
    }
    if(index != null) {
      bc.dropItem(item.base.type, index, count)
      let name = getNameOf('a', item)
      if(count) {
        name = getNameOf(count, item)
      }
      fc.addMessage('Dropped ' + name + '.')
    }
  }

  playerMotionRelative(relPos) {
    const bc = this.backController
    const fc = this.frontController

    const player = bc.getPlayer()

    const target = fc.getTarget()

    if(target.pos == null) {
      const playerOldPos = bc.getPlayerPos()
      const playerNewPos = 
        playerOldPos
        .add(relPos)
        .wrap(bc.getLevelSize())

      if(!bc.isFieldPosValid(playerNewPos)) {
        fc.addMessage("You can't move there.")
        return
      }

      if(bc.isFieldPosOccupied(playerNewPos)) {
        if(fc.motionModeAttack()) {
          this.playerAttack(playerNewPos)
          return
        } else {
          fc.addMessage("That space is already occupied.")
          return
        }
      }

      if(!fc.motionModeMove()) {
        fc.addMessage("There is nothing to attack there.")
        return
      }

      const cell = bc.getCell(playerNewPos)
      for(let item of cell.onFloor) {
        fc.addMessage(getNameOf('a', item, 'is') + ' here.')
      }

      this.occupantMove(bc.getPlayer(), playerNewPos)
      this.advanceTime(true);
    } else {
      // target mode is on
      const targetNewPos = 
        target
          .pos
          .add(relPos)
          .wrap(bc.getLevelSize())

      if(!bc.isFieldPosValid(targetNewPos)) {
        return
      }

      this.setTarget(targetNewPos)
    }
  }

  playerAttack(target) {
    const bc = this.backController
    const fc = this.frontController

    const targetCell = bc.getCell(target)
    const targetActor = targetCell.occupiedBy
    if(targetActor.health == null) {
      fc.addMessage("You can't attack that.")
      return
    }

    const player = bc.getPlayer()
    const damage = this.calculateDamageFrom(player)
    targetActor.health -= damage
    const targetName = getNameOf('the', targetActor)
    let message
    if(damage > 0) {
      message = 'You hit ' + targetName + ' for ' + damage + ' damage.'
    } else {
      message = 'You miss ' + targetName + '.'
    }
    fc.addMessage(message)

    message = ''
    if(targetActor.health <= 0) {
      message = 'The ' + targetName + ' is dead.'; 
      targetCell.occupiedBy = null
      bc.removeActor(targetActor)
      fc.setLevelChanged(true)
    } else {
      if(damage > 0) {
        message = 'hp=' + targetActor.health
      }
    }
    if(message) {
      fc.addMessage(message)
    }

    this.advanceTime(true)
  }

  clearMessages() {
    this.frontController.clearMessages()
  }

  getKeyMode() {
    return this.frontController.getKeyMode()
  }

  setKeyMode(keyModeName) {
    this.frontController.setKeyMode(keyModeName)
    if(keyModeName != 'target') {
      this.frontController.setTarget(null)
    }
  }

  refresh() {
    this.update(true)
  }

  update(forceRefresh = false) {
    const screen = this.frontController.getCurrentScreen()
    this.updateScreen(screen, forceRefresh)
  }

  updateScreen(screen, forceRefresh = false) {
    for(const window of Object.values(screen.window)) {
      this.updateWindow(screen, window, forceRefresh)
    }
  }

  updateWindow(screen, window, forceRefresh = false) {

    const fc = this.frontController
    const bc = this.backController

    let pos
    let target = fc.getTarget()
    if(target.pos) {
      pos = target.pos
    } else {
      pos = bc.getPlayerPos()
    }

    fc.checkPan(window, pos, bc.getLevelSize())

    let changed = false
    let cellsChanged = []
    if(window.name == 'status') {
      changed = fc.getStatusChanged() 
    } else if(window.name == 'level') {
      changed = fc.getLevelChanged() 
      cellsChanged = fc.getLevelCellsChanged()
    } else if(window.name == 'message') {
      changed = fc.getMessagesChanged() 
    }

    if(changed || forceRefresh) {
      fc.clearWindow(screen, window)
      this.drawWindow(screen, window)
    } else if(cellsChanged.length) {
      fc.clearWindowCells(screen, window, cellsChanged)
      this.drawLevelWindowCells(
        screen, 
        window, 
        cellsChanged,
      )
    }

    if(window.name == 'status') {
      fc.setStatusChanged(false) 
    } else if(window.name == 'level') {
      fc.setLevelChanged(false) 
      fc.clearLevelCellsChanged()
    } else if(window.name == 'message') {
      fc.setMessagesChanged(false) 
    }

  }

  drawWindow(screen, window) {

    const fc = this.frontController
    const bc = this.backController
    const mainWindows = screens.main.window

    if(window == mainWindows.level) {

      for(let c = 0; c < window.size.x; c++) {
        for(let r = 0; r < window.size.y; r++) {
          this.drawLevelWindowCell(
            new Pair(c, r),
          )
        }
      }

      const targetPos = fc.getTarget().pos
      if(targetPos) {
        fc.drawTarget(screen, window, targetPos, bc.getLevelSize())
      }

      fc.drawCenterLines(screen, window, bc.getLevelSize())

    } else if(window == mainWindows.message) {

      fc.drawMessagesWindow(screen, window)

    } else if(window == mainWindows.status) {

      const statusList = this.getStatusList()
      fc.drawStatusWindow(screen, window, statusList)

    } else {

      const windowName = fc.windowToWindowName(screen, window)
      warn("Don't know how to draw this window yet: " + windowName)

    }

  }

  drawLevelWindowCells(screen, window, cells) {
    for(const windowPos of cells) {
      this.drawLevelWindowCell(windowPos)
    }
  }

  drawLevelWindowCell(windowPos) {

    const bc = this.backController
    const fc = this.frontController
    const level = bc.getLevel()
    const player = bc.getPlayer()
    const screen = screens.main
    const window = screens.main.window.level

    if(fc.windowPosIsValid(window, windowPos, level)) {

      const levelPos = fc.windowCellPosToLevel(
        window, 
        windowPos, 
        bc.getLevelSize(),
      )
      const cell = level[levelPos.x][levelPos.y]
      let characterToDraw
      let offset
      const visibility = 
        bc.checkCellVisibility(player, levelPos)

      const remembered = bc.fetchCellFromVisionMemory(
        player, levelPos,
      )
      let subject
      if(visibility >= 2) {
        if(cell.occupiedBy) {
          subject = cell.occupiedBy.base
          characterToDraw = subject.showAs
        } else if(cell.onFloor.length > 0) {
          subject = cell.onFloor[0].base
          characterToDraw = subject.showAs
        } else {
          subject = cell.floorType.base
          characterToDraw = subject.showAs
        }
        offset = subject.offset
        if(!levelPos.equals(player.pos)) {
          bc.updateCellVisionMemory(
            player, 
            levelPos, 
            { 
              toDraw: characterToDraw,
              size: subject.size,
            },
          )
        }
      } else if(visibility == 1) {
        if(cell.occupiedBy) {
          subject = cell.occupiedBy.base
          if(subject.size > size.medium) {
            characterToDraw = template.object.somethingBig.showAs
          } else {
            characterToDraw = template.object.somethingSmall.showAs
          }
        } else if(cell.onFloor.length > 0) {
          subject = cell.onFloor[0].base
          characterToDraw = subject.showAs
        } else {
          subject = cell.floorType.base
          characterToDraw = subject.showAs
        }
        offset = subject.offset
        if(subject.size == null) {
          err("Item is missing size property")
        }
        if(remembered && remembered.size == subject.size) {
          characterToDraw = remembered.toDraw
        }
      } else {
        // cell isn't visible
        if(remembered) {
          characterToDraw = remembered.toDraw
        }
      }

      if(visibility < 1) {
        characterToDraw = [{
          text: characterToDraw || ' ',
          bgStyle: '#bbb',
        }]
      } else if(visibility < 2) {
        characterToDraw = [{
          text: characterToDraw,
          style: '#00000080',
          bgStyle: '#ddd',
        }]
      }

      fc.drawText({
        screen: screen,
        window: window,
        windowPos: windowPos, 
        textToDraw: characterToDraw, 
        offset: offset,
        centerX: true,
        centerY: true,
        textOffset: new Pair(0, 3),
        cellSizePixels: window.cellPixelDimensions,
        maxColumns: 1,
      })

    }

  }

  getStatusList() {

    const bc = this.backController
    const fc = this.frontController
    const list = []
    const player = bc.getPlayer()

    list.push('Action: ' + fc.getActionModeMessage())
    list.push(
      'Time:' + bc.getGameClock()
    + ' $:' + player.gold
    + ' Level: ' + player.level
    )
    list.push('')
    list.push('')

    // this isn't useful here...
    // const attributes = bc.getAttributes(player)
    // list.push(
    //   'str:' + ('' + attributes.strength).padStart(3,'0')
    // + ' dex:' + ('' + attributes.dexterity).padStart(3,'0')
    // + ' int:' + ('' + attributes.intelligence).padStart(3,'0')
    // )

    if(fc.getStatusMode() == 'compact') {
      this.getStatusListPoolsCompact(list, player)
    } else {
      this.getStatusListPoolsExpanded(list, player)
    }

    if(bc.getCreatorMode()) {
      list.push(colorize.rainbow('***** CREATOR MODE *****'))
    }

    this.getStatusListAwakened(list, player)
    this.getStatusListFocus(list, player)
    this.getStatusListChannels(list, player)
    this.getStatusListSounds(list, player)
    this.getStatusListSmells(list, player)
    this.getStatusListHeat(list, player)
    this.getStatusListExperienceCompass(
      list, player, bc.getExperiencePotionInLevel()
    )

    return list

  }

  getStatusListExperienceCompass(list, player, potion) {
    const bc = this.backController
    if(potion) {
      const levelSize = bc.getLevelSize()
      const unwrappedTarget = 
        potion.pos.unwrap(player.pos, levelSize)
      const direction = player.pos.directionTo(unwrappedTarget)
      const distance = player.pos.distance(unwrappedTarget)
      let distanceString
      if(distance > levelSize.x / 4) {
        distanceString = 'far'
      } else if(distance > levelSize.x / 12) {
        distanceString = 'close'
      } else {
        distanceString = 'very close'
      }
      list.push('Experience Potion:')
      list.push(
        '  ' 
        + direction
        + ' ('
        + distanceString
        + ')'
      )
    }
  }

  getStatusListHeat(list, player) {

    const bc = this.backController
    const heat = bc.getHeatAt(player.pos)

    list.push(
      'Temp: ' 
    + autoRound(heat)
    )

  }

  getStatusListSmells(list, player) {

    const bc = this.backController
    const smells = bc.getSmellsAt(player.pos)

    if(smells.length) {

      const sensitivity = bc.getSmellSensitivity(player)
      const threshold = 1 / sensitivity
      const detected = []
      const levelSize = bc.getLevelSize()

      for(const smell of smells) {

        if(smell.amount > threshold) {
          detected.push(smell)
        }

      }

      if(detected.length) {
        list.push('Smelled:')
        detected.sort( (a, b) => b.amount - a.amount )
        const smellDepth = Math.floor(bc.getSmellDepth(player))
        detected.length = Math.min(detected.length, smellDepth)
        detected.forEach((smell) => {
          let directionString = ''
          if(smell.direction) {
            directionString = '/' + smell.direction
          }
          list.push(
            '  ' 
          + smell.base.name 
          + ' (' 
          + autoRound(smell.amount)
          + directionString
          + ')'
          )
        })
      }

    }
  }

  getStatusListSounds(list, player) {

    const bc = this.backController
    const sounds = bc.getSounds()

    if(sounds.length) {

      const backgroundNoise = bc.getLevelBackgroundNoise()
      const sensitivity = bc.getHearingSensitivity(player)
      const threshold = 1 / sensitivity
      const heard = []
      const levelSize = bc.getLevelSize()

      for(const sound of sounds) {

        const distance = 
          sound.pos.wrappedDistance(player.pos, levelSize)
        const volume = sound.volume * 2 ** (-distance / 10)
        const unwrappedTarget = 
          sound.pos.unwrap(player.pos, levelSize)
        if(volume > threshold && volume > backgroundNoise) {
          heard.push({
            name: sound.name,
            volume: volume,
            direction: player.pos.directionTo(unwrappedTarget),
          })
        }

      }

      if(heard.length) {
        list.push('Heard:')
        heard.sort( (a, b) => b.volume - a.volume )
        const hearingDepth = Math.floor(bc.getHearingDepth(player))
        heard.length = Math.min(heard.length, hearingDepth)
        heard.forEach((sound) => {
          list.push(
            '  ' 
          + sound.name 
          + ' (' 
          + autoRound(sound.volume)
          + '/' 
          + sound.direction 
          + ')'
          )
        })
      }

    }
  }

  getStatusListAwakened(list, player) {
    if(player.awakenedPools.length) {
      let awakenedList = [ text('Awakened:') ]
      player.awakenedPools.forEach(pool => {
        awakenedList.push(text(' '))
        awakenedList.push(colorizePoolName(pool))
      })
      list.push(awakenedList)
    }
  }

  getStatusListFocus(list, player) {
    const focus = player.focus
    if(focus) {
      let output
      if(focus.objectClass == 'pool') {
        output = colorizePoolName(focus)
      } else if(focus.objectClass == 'sense') {
        output = text(focus.name)
      } else {
        err('Unknown focus class: ' + focus.objectClass)
      }
      list.push([
        text('Focus: '),
        output,
      ])
      if(player.medDepth) {
        list.push(
          'Meditation Depth: '
          + autoRound(player.medDepth)
        )
      }
    }
  }

  getChangeString(prefix, change) {
    let changeString
    if(change < 0.001 && change > -0.001) {
      changeString = ''
    } else {
      if(change >= 0) {
        changeString = prefix + '+' + autoRound(change)
      } else if(change < 0) {
        changeString = prefix + '-' + autoRound(-change)
      }
    }
    return changeString
  }

  addStatusPoolLineExpanded(list, player, poolList) {

    const bc = this.backController
    let line = ''

    for(const poolName of poolList) {

      const index = poolNameToIndex(poolName)
      const pool = pools[poolName]
      const current = '' + Math.round(
        getPoolCurrent(player, index)
      )
      const max = '' + Math.round(getPoolMax(player, poolName))
      const currentChange = bc.getPoolCurrentChange(player, index)
      // const maxChange = bc.getPoolMaxChange(player, index)
      let currentChangeString = this.getChangeString(
        ' ',currentChange
      )
      // let maxChangeString = this.getChangeString(' max',maxChange)
      const digits = bc.getPoolDigits(player)

      line += pool.shortName[1] + ': ' 
        + current.padStart(digits)
        + '/' 
        + max.padStart(digits)
        + currentChangeString 

      line = [{ 
        style: pool.color.style, 
        bgStyle: pool.color.bgStyle, 
        text: line 
      }]

    }

    list.push(line)

  }

  getStatusListPoolsExpanded(list, player) {

    list.push(' Interna')
    this.addStatusPoolLineExpanded(list, player, ['criticalHealth'])
    this.addStatusPoolLineExpanded(list, player, ['majorHealth'])
    this.addStatusPoolLineExpanded(list, player, ['minorHealth' ])
    this.addStatusPoolLineExpanded(list, player, ['stamina'])
    this.addStatusPoolLineExpanded(list, player, ['mana'])
    this.addStatusPoolLineExpanded(list, player, ['willpower'])

    list.push(' Lumina')
    this.addStatusPoolLineExpanded(list, player, ['sun'])
    this.addStatusPoolLineExpanded(list, player, ['moon'])
    this.addStatusPoolLineExpanded(list, player, ['star'])
    this.addStatusPoolLineExpanded(list, player, ['gray'])
    this.addStatusPoolLineExpanded(list, player, ['black'])

    list.push(' Etherea')
    this.addStatusPoolLineExpanded(list, player, ['diamond'])
    this.addStatusPoolLineExpanded(list, player, ['gold'])
    this.addStatusPoolLineExpanded(list, player, ['silver'])
    this.addStatusPoolLineExpanded(list, player, ['copper'])

    list.push(' Spectra')
    this.addStatusPoolLineExpanded(list, player, ['red'])
    this.addStatusPoolLineExpanded(list, player, ['orange'])
    this.addStatusPoolLineExpanded(list, player, ['yellow'])
    this.addStatusPoolLineExpanded(list, player, ['green'])
    this.addStatusPoolLineExpanded(list, player, ['cyan'])
    this.addStatusPoolLineExpanded(list, player, ['blue'])
    this.addStatusPoolLineExpanded(list, player, ['indigo'])
    this.addStatusPoolLineExpanded(list, player, ['violet'])

    list.push(' Exotica')
    this.addStatusPoolLineExpanded(list, player, ['rainbow'])
    this.addStatusPoolLineExpanded(list, player, ['brown'])
    this.addStatusPoolLineExpanded(list, player, ['purple'])

  }

  addStatusPoolLineCompact(list, player, poolList) {
    const bc = this.backController
    let line = ''
    for(const poolName of poolList) {
      const index = poolNameToIndex(poolName)
      const pool = pools[poolName]
      const percent = bc.getPoolPercent(player, index)
      line += ' ' + pool.shortName[1] + ':' + percent
    }
    list.push(line)
  }

  getStatusListPoolsCompact(list, player) {

    list.push(' Interna')
    this.addStatusPoolLineCompact(list, player, [
      'criticalHealth', 
      'majorHealth', 
      'minorHealth',
    ])
    this.addStatusPoolLineCompact(list, player, [
      'stamina', 
      'mana', 
      'willpower',
    ])

    list.push(' Lumina')
    this.addStatusPoolLineCompact(list, player, [
      'black', 
      'gray', 
      'star',
      'moon',
      'sun',
    ])

    list.push(' Etherea')
    this.addStatusPoolLineCompact(list, player, [
      'copper',
      'silver',
      'gold',
      'diamond',
    ])

    list.push(' Spectra')
    this.addStatusPoolLineCompact(list, player, [
      'red',
      'orange',
      'yellow',
      'green',
    ])
    this.addStatusPoolLineCompact(list, player, [
      'cyan',
      'blue',
      'indigo',
      'violet',
    ])

    list.push(' Exotica')
    this.addStatusPoolLineCompact(list, player, [
      'rainbow',
      'brown',
      'purple',
    ])

  }

  getStatusListChannels(list, player) {

    const bc = this.backController
    const maxColumns = 3
    list.push('Channels')
    let channelsToOutput = []

    for(let i = 0; i < poolChannels.length; i++) {
      const flow = player.channelCurrent[i]
      if(flow) {
        const channel = poolChannels[i]
        for(let f = 0; f < channel.from.length; f++) {
          const from = channel.from[f]
          for(let t = 0; t < channel.to.length; t++) {

            const to = channel.to[t]

            let innerList = channelsToOutput[flow]
            if(!innerList) {
              innerList = []
              channelsToOutput[flow] = innerList
            }

            const channelString = getChannelString(
              player, 
              from, 
              to,
            )

            innerList.push(channelString)

          }
        }
      }
    }

    for(let i = 9; i > 0; i--) {
      const c = channelsToOutput[i]
      if(c) {
        let line = [text(i + ':')]
        let col = 0
        const channelList = channelsToOutput[i]
        for(let ci = 0; ci < channelList.length; ci++) {
          line = [ ...line, text(' '), ...channelList[ci] ]
          col++
          if(col == maxColumns) {
            list.push(line)
            line = [text('  ')]
            col = 0
          }
        }
        if(line.length > 2) {
          list.push(line)
        }
      }
    }

  }

  outputTargetMessages() {
    const bc = this.backController
    const fc = this.frontController
    const cell = bc.getCell(fc.getTarget().pos)
    if(cell.occupiedBy) {
      fc.addMessage(describeItem(cell.occupiedBy))
    }
    for(let item of cell.onFloor) {
      fc.addMessage(describeItem(item))
    }
    if(cell.floorType) {
      fc.addMessage(describeItem(cell.floorType))
    }
    if(bc.getCreatorMode()) {
      fc.addMessage('')
      fc.addMessage('c - create')
      fc.addMessage('d - delete target')
      fc.addMessage('t - teleport to target')
    }
  }

  advanceTime(playerActive) {
    const bc = this.backController
    const fc = this.frontController
    const player = bc.getPlayer()
    bc.getActors().forEach(actor => {
      this[actor.base.act](actor)
    })
    bc.applyEnergyDelta(player)
    bc.advanceEnergyFlow(player)
    fc.setStatusChanged(true)
    if(playerActive) didSomething = true
    bc.decaySound()
    bc.spreadSmell()
    bc.spreadHeat()
  }
  
  simplePursuit(actor) {
    const bc = this.backController
    const adjacent = bc.adjacentCells(actor.pos)
    const player = bc.getPlayer()
    for(let i = 0; i < adjacent.length; i++) {
      let pos = adjacent[i]
      let cell = bc.getCell(pos)
      if(cell.occupiedBy == player) {
        this.executeAttack(actor, player)
        return
      }
    }

    if(random(3) == 0) {
      let pos = adjacent[random(adjacent.length)]
      let cell = bc.getCell(pos)
      if(cell.occupiedBy == null) {
        this.executeMove(actor, pos)
      }
    }

    const sound = actor.base.sound
    if(sound) {
      if(random(1000) < sound.chance * 1000) {
        bc.makeSound(sound.name, sound.volume, actor.pos)
        this.frontController.setStatusChanged(true)
      }
    }

    const smell = actor.base.smell
    if(smell) {
      bc.addSmell(actor.pos, smell)
    }

    const heat = actor.base.heat.amount
    if(heat) {
      bc.addHeat(actor.pos, heat)
    }

  }

  calculateDamageFrom(attacker) {
    let minDamage = 0
    let maxDamage = 0
    if(attacker.attack != null) {
      minDamage = attacker.attack.min
      maxDamage = attacker.attack.max
    }
    return Math.floor(Math.random() * (1 + maxDamage - minDamage)) + minDamage
  }

  executeMove(actor, pos) {
    this.occupantMove(actor, pos)
  }

  adjustHealth(target, change) {

    target.health += change
    const player = this.backController.getPlayer()

    if(target.health <= 0) {
      if(target == player) {
        err("Not implemented yet")
        // fc.addMessage("You died. Press 'R' to restart.")
        // setKeyListener(rKeyHandler, restart)
      }
    }

    if(change != 0 && target == player) {
      this.frontController.setStatusChanged(true)
    }

  }

  executeAttack(source, target) {
    let damage = this.calculateDamageFrom(source)

    let message;
    if(damage > 0) {
      message = getNameOf('the', source) 
        + " hit you for " + damage + " damage."
      this.frontController.addMessage(message)
      this.adjustHealth(target, -damage)
    } else {
      message = getNameOf('the', source) + " missed you."
      this.frontController.addMessage(message)
    }
  }

  occupantMove(occupant, toPos) {
    const bc = this.backController
    const fc = this.frontController

    const fromPos = occupant.pos
    if(fromPos != null) {
      bc.getCell(fromPos).occupiedBy = null
      fc.addLevelCellsChanged(
        fc.levelPosToWindowPos(fromPos, bc.getLevelSize())
      )
    }
    if(bc.getCell(toPos).occupiedBy != null) {
      err(
        'Cell at ' + toPos.x + ', ' 
        + toPos.y + ' is already occupied'
      )
    }
    bc.getCell(toPos).occupiedBy = occupant
    fc.addLevelCellsChanged(
      fc.levelPosToWindowPos(toPos, bc.getLevelSize())
    )

    occupant.pos = toPos
  }

  setMotionMode(mode) {
    this.frontController.setMotionMode(mode)
  }

  setTarget(pos) {
    const fc = this.frontController
    const bc = this.backController
    fc.setTarget(pos)
    if(pos) {
      this.outputTargetMessages()
    }
  }

  getPlayerPos() {
    return this.backController.getPlayerPos()
  }

}

class BackController {

  constructor() {
    this.backModel = _.cloneDeep(template.backModel)
    this.initRandomizers()
    this.initItems()
    this.buildLevel()
    this.initSpecies()
    this.initializePlayer()
  }

  getExperiencePotionInLevel() {
    return this.backModel.experiencePotionInLevel
  }

  getMaxMeditationDepth(actor) {
    const medSkill = this.getSkill(actor, 'meditation')
    const maxDepth = 4 * (1 + medSkill / 5)
    return maxDepth
  }

  getMeditationRate(actor) {
    const medSkill = this.getSkill(actor, 'meditation')
    const medRate = 2 * (1 + medSkill / 3)
    return medRate
  }

  getSounds() {
    const sounds = this.backModel.sounds
    return sounds
  }

  makeSound(name, volume, pos) {
    const sounds = this.backModel.sounds
    sounds.push({
      name: name,
      volume: volume * 2,
      pos: pos,
    })
  }

  decaySound() {
    const bm = this.backModel
    const sounds = bm.sounds
    const newSounds = []
    for(const sound of sounds) {
      const newVolume = sound.volume / 2
      if(newVolume >= 1) {
        const newSound = {
          ...sound,
          volume: newVolume,
        }
        newSounds.push(newSound)
      }
    }
    bm.sounds = newSounds
  }

  getCellGlow(pos) {
    return this.backModel.glowGrid[pos.x]?.[pos.y] || 0
  }

  addCellGlow(pos, amount) {
    const oldValue = this.getCellGlow(pos)
    let newValue = oldValue + amount
    if(newValue < 0) newValue = 0
    this.setCellGlow(pos, newValue)
  }

  setCellGlow(pos, amount) {
    set(this.backModel.glowGrid, [pos.x, pos.y], amount)
  }

  updateCellVisionMemory(actor, pos, character) {
    set(actor.memory.sight, [pos.x, pos.y], character)
  }

  fetchCellFromVisionMemory(actor, pos) {
    return actor.memory.sight[pos.x]?.[pos.y]
  }

  checkCellVisibility(actor, wrappedPos) {

    let visibility = 0
    let cellGlow = this.getCellGlow(wrappedPos)

    if(actor.pos.equals(wrappedPos)) {
      visibility = 2
    } else {

      const levelSize = this.backModel.levelSize
      const pos = wrappedPos.unwrap(actor.pos, levelSize)
      const distance = actor.pos.distance(pos)
      const visionRadius = this.getVisionRadius(actor)

      const fullDelta = pos.subtract(actor.pos)
      let blocked = false

      if(fullDelta.x == 0 || fullDelta.y == 0) {
        blocked = this.checkCellVisibilityToEdgeOrthagonal(
          actor, pos, fullDelta
        )
      } else {
        blocked = this.checkCellVisibilityToEdgeDiagonal(
          actor, pos, fullDelta
        )
      }

      visibility = 0
      if(!blocked) {
        visibility = 2
        if(distance > visionRadius * 2) {
          visibility = 0
        } else if(distance > visionRadius) { 
          visibility = 1
        }
        visibility += cellGlow
      }

    }

    return visibility

  }

  checkCellVisibilityToEdgeOrthagonal(actor, edge, fullDelta) {

    let from
    let to
    let horizontal
    let increment
    let blocked = false

    if(fullDelta.x != 0) {
      from = actor.pos.x
      to = edge.x
      horizontal = true
    } else {
      from = actor.pos.y
      to = edge.y
      horizontal = false
    }

    if(from < to) {
      for(let i = from + 1; i < to; i++) {
        let pos
        if(horizontal) {
          pos = new Pair(i, edge.y)
        } else {
          pos = new Pair(edge.x, i)
        }
        blocked = this.checkCellVisibilityToEdge(actor, pos)
        if(blocked) break
      }
    } else {
      for(let i = from - 1; i > to; i--) {
        let pos
        if(horizontal) {
          pos = new Pair(i, edge.y)
        } else {
          pos = new Pair(edge.x, i)
        }
        blocked = this.checkCellVisibilityToEdge(actor, pos)
        if(blocked) break
      }
    }

    return blocked
  }

  checkCellVisibilityToEdgeDiagonal(actor, edge, fullDelta) {

    let blocked = false

    const from = actor.pos.add(halfPair)
    const to = edge.add(halfPair)

    if(from.equals(to)) {
      err("from and to must be different.")
    }

    let dx
    const slope = fullDelta.y / fullDelta.x
    if(Math.abs(fullDelta.x) < Math.abs(fullDelta.y)) {
      dx = 1 / slope
    } else {
      dx = slope
    }
    dx = Math.abs(dx)

    const yIntercept = from.y - slope * from.x
    const line = new Line(slope, yIntercept)

    if(from.x < to.x) {

      for(let x = from.x + dx; x < to.x; x += dx) {
        const y = slope * x + yIntercept
        const pos = new Pair(Math.floor(x), Math.floor(y))
        if(!pos.equals(edge)) {
          blocked = 
            this.checkCellVisibilityToEdge(actor, pos, line)
          if(blocked) break
        } else {
          break
        }
      }

    } else {

      for(let x = from.x - dx; x > to.x; x -= dx) {
        const y = slope * x + yIntercept
        const pos = new Pair(Math.floor(x), Math.floor(y))
        if(!pos.equals(edge)) {
          blocked = 
            this.checkCellVisibilityToEdge(actor, pos, line)
          if(blocked) break
        } else {
          break
        }
      }

    }

    return blocked

  }

  checkCellVisibilityToEdge(actor, pos, line) {

    let blocked = false
    const level = this.getLevel()
    const levelSize = this.backModel.levelSize
    const wpos = pos.wrap(levelSize)

    if(!wpos.equals(actor.pos)) {
      if(this.cellBlocksLight(
        pos, 
        level[wpos.x][wpos.y],
        line,
      )) {
        blocked = true
      }
    }

    return blocked

  }

  getVisionRadius(actor) {
    const floorBrightness = 
      this.getCurrentFloorBrightness()
      + this.getEquipBrightness(actor)
    const baseVision = actor.species.senses.sight / 10
    let focusEnhancement = 1
    if(actor.focus === senses.sight) {
      focusEnhancement += actor.medDepth * 0.1
    }
    const radius = floorBrightness * baseVision * focusEnhancement
    if(!radius) {
      err("Invalid radius: " + radius)
    }
    return radius
  }

  getCurrentFloorBrightness() {
    // right now all floors are the same
    return 4
  }

  getEquipBrightness(actor) {
    let totalBrightness = 0
    const equip = actor.equip
    for(const [key, value] of Object.entries(equip)) {
      if(key == 'hand' || key == 'ring') {
        for(const item of equip[key]) {
          totalBrightness += this.getItemBrightness(item)
        }
      } else {
        totalBrightness += this.getItemBrightness(equip[key])
      }
    }
    return totalBrightness
  }

  getItemBrightness(item) {
    let brightness = 0
    if(item && item.base.glow) {
      brightness += item.base.glow
    }
    return brightness
  }

  cellBlocksLight(pos, cell, line) {

    let blocksLight = false

    if(cell.occupiedBy && cell.occupiedBy.base.size > size.medium) {
      if(
        line == null
        || !this.interceptedCorner(pos, line)
      ) {
        blocksLight = true
      }
    }

    return blocksLight

  }

  interceptedCorner(pos, line) {
    let result = false

    const segments = {
      topLeft: 
        new Segment(
          new Pair(pos.x       , pos.y), 
          new Pair(pos.x + 0.49, pos.y),
        ),
      topRight:
        new Segment(
          new Pair(pos.x + 0.51, pos.y), 
          new Pair(pos.x + 1   , pos.y),
        ),
      rightTop:
        new Segment(
          new Pair(pos.x + 1, pos.y       ), 
          new Pair(pos.x + 1, pos.y + 0.49),
        ),
      rightBottom:
        new Segment(
          new Pair(pos.x + 1, pos.y + 0.51), 
          new Pair(pos.x + 1, pos.y + 1   ),
        ),
      bottomLeft:
        new Segment(
          new Pair(pos.x + 0.49, pos.y + 1),
          new Pair(pos.x       , pos.y + 1), 
        ),
      bottomRight:
        new Segment(
          new Pair(pos.x + 1   , pos.y + 1),
          new Pair(pos.x + 0.51, pos.y + 1), 
        ),
      leftTop:
        new Segment(
          new Pair(pos.x, pos.y + 0.49),
          new Pair(pos.x, pos.y       ), 
        ),
      leftBottom:
        new Segment(
          new Pair(pos.x, pos.y + 1   ),
          new Pair(pos.x, pos.y + 0.51), 
        ),
    }

    if(
      line.interceptsSegment(segments.topLeft)
      && line.interceptsSegment(segments.leftTop)
      ||
      line.interceptsSegment(segments.topRight)
      && line.interceptsSegment(segments.rightTop)
      ||
      line.interceptsSegment(segments.bottomLeft)
      && line.interceptsSegment(segments.leftBottom)
      ||
      line.interceptsSegment(segments.bottomRight)
      && line.interceptsSegment(segments.rightBottom)
    ) {
      result = true
    }

    return result
  }

  getLevelBackgroundNoise() {
    // fixed for now
    return 0.5
  }

  getHearingSensitivity(actor) {
    const baseHearing = actor.species.senses.sound / 10
    let focusEnhancement = 1
    if(actor.focus === senses.sound) {
      focusEnhancement += actor.medDepth * 0.1
    }
    const sensitivity = baseHearing * focusEnhancement
    return sensitivity
  }

  getHearingDepth(actor) {
    const baseHearing = actor.species.senses.sound / 10
    let focusEnhancement = 1
    if(actor.focus === senses.sound) {
      focusEnhancement += actor.medDepth * 0.1
    }
    const hearingDepth = baseHearing * focusEnhancement * 2
    return hearingDepth
  }

  addSmell(pos, smell) {

    const bm = this.backModel
    const smellIndexes = bm.smellIndexes
    const minimumSmellLevel = 0.001

    let smellIndex

    for(let i in smellIndexes) {
      if(smellIndexes[i] === smell) {
        smellIndex = i
      }
    }

    if(smellIndex == null) {
      smellIndex = smellIndexes.length
      smellIndexes.push(smell)
      bm.smells[smellIndex] = []
      const levelSize = bm.levelSize
      for(let x = 0; x < bm.levelSize.x; x++) {
        bm.smells[smellIndex][x] = []
        for(let y = 0; y < bm.levelSize.y; y++) {
          bm.smells[smellIndex][x][y] = 0
        }
      }
      bm.smellCellCounts[smellIndex] = 0
    }

    let currentSmell = bm.smells[smellIndex][pos.x][pos.y]

    if(currentSmell == 0) {
      bm.smellCellCounts[smellIndex]++
    }

    currentSmell += smell.amount
    bm.smells[smellIndex][pos.x][pos.y] = currentSmell

    if(currentSmell < minimumSmellLevel) {
      bm.smellCellCounts[smellIndex]--
      if(bm.smellCellCounts[smellCellCounts] <= 0) {
        smellIndexes.splice(smellIndex, 1)
        bm.smellCellCounts.splice(smellIndex, 1)
        bm.smells.splice(smellIndex, 1)
      }
    }

  }

  spreadSmell() {

    const middleWeight = 10
    const decay = 0.01
    const minimumSmellLevel = 0.001

    const bm = this.backModel
    const smells = bm.smells
    const newSmells = []
    const smellIndexesToRemove = []
    
    for(let p = 0; p < smells.length; p++) {
      newSmells[p] = []
      for(let x = 0; x < smells[p].length; x++) {
        newSmells[p][x] = []

        for(let y = 0; y < smells[p][x].length; y++) {

          const pos = new Pair(x, y)
          if(this.getCell(pos)?.occupiedBy?.base?.blocksSmell) {
            continue
          }

          const adjacent = pos.adjacent(bm.levelSize)
          const oldValue = smells[p][x][y]
          let adjacentSum = 0 
          let adjacentCount = 0

          for(let adjacentPos of adjacent) {
            if(this.getCell(adjacentPos)
              ?.occupiedBy?.base?.blocksSmell) {
              continue
            }
            adjacentSum += smells[p][adjacentPos.x][adjacentPos.y]
            adjacentCount++
          }

          const adjacentAvg = adjacentSum / adjacentCount
          let newValue = 
            (1 - decay) 
            *
            (oldValue * middleWeight + adjacentAvg) 
            / 
            (middleWeight + 1)

          newSmells[p][x][y] = newValue
          if(newValue > 0 && oldValue === 0) {
            bm.smellCellCounts[p]++
          } else if(
            newValue < minimumSmellLevel 
            && oldValue > newValue
          ) {
            bm.smellCellCounts[p]--
            newValue = 0
            if(bm.smellCellCounts[p] <= 0) {
              smellIndexesToRemove.push(p)
            }
          }

        }

      }
    }

    for(let p = 0; p < smellIndexesToRemove.length; p++) {
      bm.smellIndexes.splice(p, 1)
      bm.smellCellCounts.splice(p, 1)
      newSmells.splice(p, 1)
    }

    bm.smells = newSmells

  }

  getSmellsAt(pos) {
    const bm = this.backModel
    const smells = []
    for(let p = 0; p < bm.smellIndexes.length; p++) {
      const middleSmellAmount = bm.smells[p][pos.x][pos.y]
      if(middleSmellAmount) {
        const adjacent = pos.adjacent(bm.levelSize)
        let strongestDirection = ''
        let strongestAmount = middleSmellAmount
        for(const adjacentPos of adjacent) {
          const adjacentAmount = 
            bm.smells[p][adjacentPos.x][adjacentPos.y] 
          if(
            adjacentAmount
            > strongestAmount
          ) {
            strongestAmount = adjacentAmount
            strongestDirection = pos.directionTo(adjacentPos)
          }
        }
        smells.push({
          base: bm.smellIndexes[p],
          amount: middleSmellAmount,
          direction: strongestDirection,
        })
      }
    }
    return smells
  }

  getSmellSensitivity(actor) {
    const baseSmell = actor.species.senses.smell / 10
    let focusEnhancement = 1
    if(actor.focus === senses.smell) {
      focusEnhancement += actor.medDepth * 0.1
    }
    const sensitivity = baseSmell * focusEnhancement * 100
    return sensitivity
  }

  getSmellDepth(actor) {
    const baseSmell = actor.species.senses.smell / 10
    let focusEnhancement = 1
    if(actor.focus === senses.smell) {
      focusEnhancement += actor.medDepth * 0.1
    }
    const smellDepth = baseSmell * focusEnhancement * 2
    return smellDepth
  }

  getHeatAt(pos) {
    const bm = this.backModel
    return bm.heat[pos.x][pos.y]
  }

  addHeat(pos, amount) {
    const bm = this.backModel
    bm.heat[pos.x][pos.y] += amount
  }

  spreadHeat() {

    const minHeatLevel = 0.0001

    const bm = this.backModel
    const levelSize = bm.levelSize
    const heatGrid = bm.heat
    const level = bm.level

    for(let x = 0; x < heatGrid.length; x++) {
      for(let y = 0; y < heatGrid[x].length; y++) {
        const heat = heatGrid[x][y]
        if(heat > 0) {
          const pos = new Pair(x, y)
          const pos2 = pos.randomAdjacent(levelSize)
          const heat2 = heatGrid[pos2.x][pos2.y]
          // don't do anything if it's not at least 10% difference
          if(Math.abs(heat - heat2) / heat > 0.1) {
            const subject = level[x][y].occupiedBy 
            const cap = subject?.base?.heatCapacity || 10
            const subject2 = level[pos2.x][pos2.y].occupiedBy 
            const cap2 = subject2?.base?.heatCapacity || 10
            const [from, to] = getEnergyCapacityFlow(
              heat, cap,
              heat2, cap2,
            )
            heatGrid[x][y] += from
            heatGrid[pos2.x][pos2.y] += to
            if(heatGrid[x][y] <= minHeatLevel) {
              heatGrid[x][y] = 0
              heatGrid[pos2.x][pos2.y] = 0
            }
          }
        }
      }
    }

  }

  initRandomizers() {
    const bm = this.backModel
    const randomizer = new SeededRandomizer(
      this.backModel.seed
    )
    for(const key in bm.randomizers) {
      bm.randomizers[key] = randomizer.fork()
      randomizer.next()
    }
  }

  getRandomizer(name) {
    return this.backModel.randomizers[name]
  }

  getAttribute(actor, attribute, boost = 0) {
    let value = actor.species.attributes[attribute]
    if(actor.growth) {
      let growth = actor.growth.attributes[attribute]
      growth += boost
      value += growth
    }
    return Math.floor(value)
  }

  addGrowthSelectionToGrowth() {
    const player = this.backModel.player
    const growthSelection = player.growthSelection
    const growth = player.growth
    this.addGrowthSelectionToGrowth2(growthSelection, growth)
  }

  addGrowthSelectionToGrowth2(growthSelection, growth) {
    for(const key in growthSelection) {
      const value = growthSelection[key]
      if(typeof value == 'boolean') {
        if(value) growth[key]++
      } else {
        this.addGrowthSelectionToGrowth2(
          growthSelection[key], 
          growth[key],
        )
      }
    }
  }

  // either set poolTypeToFill or poolToFill
  fillEnergy(actor, poolTypeToFill = null, poolToFill = null) {
    let i = 0
    for(const pool of Object.values(pools)) {
      if(poolTypeToFill && pool.type == poolTypeToFill) {
        this.fillPool(actor, pool)
      } else if(poolToFill && pool == poolToFill) {
        this.fillPool(actor, pool)
      }
      i++
    }
  }

  getGrowthSelection() {
    return this.backModel.player.growthSelection
  }

  getGrowthPerLevel() {
    return this.backModel.player.species.experiencePerLevel
  }

  getAttributes(actor) {
    return actor.species.attributes
  }

  initItems(inherited = {}, itemBase = template.generated.sub) {
    for(let itemKey in itemBase) {
      itemBase[itemKey] = { ...inherited, ...itemBase[itemKey] }
      if(itemBase[itemKey].sub) {
        let newItem = { ...itemBase[itemKey], sub: null }
        this.initItems(
          newItem, 
          itemBase[itemKey].sub,
        )
      } else {
        if(!itemBase[itemKey].name) {
          itemBase[itemKey].name = itemKey
        }
      }
    }
  }

  initSpecies() {
    for(let key in species) {
      if(key == 'default') continue
      species[key] = { ...species.default, ...species[key] }
    }
  }

  getPoolDigits(actor) {
    return actor.poolDigits
  }

  setChannelFlow(actor, channelIndex, flow) {
    actor.channelCurrent[channelIndex] = flow
  }

  advanceEnergyFlow(actor) {
    if(actor.focus) {
      const remaining = this.subtractEnergy(actor, 'mana', 1)
      if(remaining != 0) {
        actor.focus = null
        actor.medDepth = 0
      }
    }
    for(let pool of actor.awakenedPools) {
      this.addEnergy(actor, pool.name, 0.1)
    }
    for(let i = 0; i < poolChannels.length; i++) {
      const currentFlowMagnitude = actor.channelCurrent[i]
      const channel = poolChannels[i]
      const max = getChannelMaxFlow(actor, channel.name)
      const currentMaxFlow = getChannelFlowFromMagnitude(
        currentFlowMagnitude,
        max
      )
      this.advanceEnergyFlowChannel(actor, channel, currentMaxFlow)
    }
  }

  advanceEnergyFlowChannel(actor, channel, currentMaxFlow) {
    for(let f = 0; f < channel.from.length; f++) {
      const from = channel.from[f]
      for(let t = 0; t < channel.to.length; t++) {
        const to = channel.to[t]
        this.advanceEnergyFlowPools(actor, from, to, currentMaxFlow)
      }
    }
  }

  advanceEnergyFlowPools(actor, from, to, currentMaxFlow) {

    const poolIndexFrom = poolNameToIndex(from.name)
    const poolIndexTo = poolNameToIndex(to.name)

    if(poolIndexFrom == -1 || poolIndexTo == -1) {
      err("Could not find pool")
    }

    const fCur = actor.poolCurrent[poolIndexFrom]
    const tCur = actor.poolCurrent[poolIndexTo]
    const fMax = getPoolMax(actor, from.name)
    const fMaxLimit = getPoolMax(actor, from.name, 0, true)
    const tMax = getPoolMax(actor, to.name)
    const tMaxLimit = getPoolMax(actor, to.name, 0, true)

    const tierMultiplier = 10 ** (from.tier - to.tier)
    const fCur2 = fCur * tierMultiplier
    const fMax2 = fMax * tierMultiplier
    const fMaxLimit2 = fMaxLimit * tierMultiplier

    const bias = getBias(actor, from, to)
    const upBias = bias.upBias
    const downBias = bias.downBias

    const n = 
      fCur2 * tMax * (1 + downBias)
    - tCur * fMax2 * (1 + upBias)

    const d = 
      tMax * (1 + downBias)
    + fMax2 * (1 + upBias)

    const equalizer = n / d
    const sign = Math.sign(equalizer)

    let fRoom
    let tRoom
    if(sign > 0) {
      // flowing down
      fRoom = fCur2
      tRoom = tMaxLimit - tCur
    } else {
      // flowing up
      fRoom = fMaxLimit2 - fCur2
      tRoom = tCur
    }

    const deltaAbs = 
      Math.min(
        Math.abs(equalizer), 
        currentMaxFlow,
        fRoom,
        tRoom,
      ) 

    // no energy flows if we can't at least change 1 point of 
    // energy on the higher tier
//    if(deltaAbs >= 1 * tierMultiplier) {
      const delta = deltaAbs * sign
      actor.poolCurrent[poolIndexFrom] -= delta / tierMultiplier
      actor.poolCurrent[poolIndexTo]   += delta
//    }

  }

  applyEnergyDelta(actor) {
    const deltas = actor.species.energyDelta
    if(deltas) {
      for(let [energyType, amount] of Object.entries(deltas)) {
        if(amount > 0) {
          this.addEnergy(actor, energyType, amount)
        } else {
          this.subtractEnergy(actor, energyType, -amount)
        }
      }
    }
  }

  fillPool(actor, pool) {
    const poolIndex = pool.index
    const maxValue = getPoolMax(actor, pool.name)
    if(actor.poolCurrent[poolIndex] < maxValue) {
      actor.poolCurrent[poolIndex] = maxValue
    }
  }

  setPool(actor, pool, amount) {
    const poolIndex = pool.index
    actor.poolCurrent[poolIndex] = amount
  }

  subtractEnergy(actor, energyType, amount) {

    let poolIndex = -1
    let poolsToTry = []

    if(energyType == 'health') {
      poolsToTry = ['minorHealth', 'majorHealth', 'criticalHealth']
    } else {
      poolsToTry = [energyType]
    }

    let remaining = amount

    while(remaining != 0 && poolsToTry.length) {

      energyType = poolsToTry.shift()
      poolIndex = poolNameToIndex(energyType)
      if(poolIndex == -1) {
        err("Couldn't identify energy type: " + energyType)
      }

      const oldValue = actor.poolCurrent[poolIndex]
      const change = Math.min(oldValue, remaining)
      const newValue = oldValue - change

      remaining -= change

      actor.poolCurrent[poolIndex] = newValue

    }

    return remaining

  }

  addEnergy(actor, energyType, amount) {

    const poolIndex = poolNameToIndex(energyType)
    const oldValue = actor.poolCurrent[poolIndex]
    const maxValue = getPoolMax(
      actor, 
      energyType, 
      0, 
      true
    )

    const change = Math.min(maxValue - oldValue, amount)
    let newValue = oldValue + change
    amount -= change

    actor.poolCurrent[poolIndex] = newValue

    return amount

  }

  // returns the pool percentage as a padded string
  getPoolPercent(actor, poolIndex) {
    return ('' + Math.round(
      actor.poolCurrent[poolIndex] * 100
      /
      getPoolMax(actor, poolIndexToName(poolIndex))
      )
    ).padStart(3, '0')
  }

  getPoolCurrentChange(actor, poolIndex) {
    return actor.poolCurrent[poolIndex] 
      - actor.poolCurrentPast[poolIndex]
  }

  getPoolMaxChange(actor, poolIndex) {
    return actor.poolMax[poolIndex] 
      - actor.poolMaxPast[poolIndex]
  }

  getSkill(actor, skillName, boost = 0) {
    let value = 0
    let aptitude = 
      actor.species.aptitudes[skillName]
      || actor.species.aptitudes.default
    if(actor.growth) {
      let growth = actor.growth.skills[skillName]
      growth += boost
      value += growth * aptitude
    }
    return autoRound(value)
  }

  setSkill(actor, skillName, value) {
    actor.growth.skills[skillName] = value
  }

  initializePlayer() {

    const player = this.getPlayer()
    const levelSize = this.backModel.levelSize

    player.species = species.human
    let i

    for(i in senses) {
      const sense = senses[i]
      sense.name = i
      sense.objectClass = 'sense'
    }

    for(i in poolTypes) {
      const poolType = poolTypes[i]
      poolType.name = i
    }

    for(i in skillTypes) {
      const skillType = skillTypes[i]
      skillType.name = i
    }

    for(i in skills) {
      const skill = skills[i]
      skill.name = i
      skill.objectClass = 'skill'
    }

    for(i = 0; i < poolChannels.length; i++) {

      player.channelCurrent[i] = 0
      const channel = poolChannels[i]
      channel.index = i

      let fromName = channel.from[0].shortName
      if(channel.from.length > 1) {
        fromName = fromName[0] + '*'
      }

      let toName = channel.to[0].shortName
      if(channel.to.length > 1) {
        toName = toName[0] + '*'
      }

      channel.name = fromName + '-' + toName

      if(channel.to[0].type == poolTypes.interna) {
        player.channelCurrent[i] = 9
      }

      let maxChannelSize = player.species.maxChannelSizes[i]

      if(!maxChannelSize) {
        maxChannelSize = player.species.maxChannelSizeDefault
      }

      player.channelMax[i] = maxChannelSize

      const heat = this.backModel.heat
      for(let x = 0; x < levelSize.x; x++) {
        heat[x] = []
        for(let y = 0; y < levelSize.y; y++) {
          heat[x][y] = 100
        }
      }

    }

    i = 0
    for(let [poolName, pool] of Object.entries(pools)) {

      let maxPoolSize = player.species.maxPoolSizes[poolName]
      pool.name = poolName
      pool.objectClass = 'pool'
      pool.index = i
      pool.channelIndexes = []

      for(let c = 0; c < poolChannels.length; c++) {
        let channel = poolChannels[c]
        if(
           channel.from.some(x => x == pool)
          || channel.to.some(x => x == pool)
        ) {
          pool.channelIndexes.push(channel.index)
        }
      }

      if(!maxPoolSize) {
        maxPoolSize = player.species.maxPoolSizes.default
      }

      player.poolMax[i] = maxPoolSize

      if(pool.type == poolTypes.interna) {
        player.poolCurrent[i] = maxPoolSize
      } else if(pool.type == poolTypes.spectra) {
        player.poolCurrent[i] = maxPoolSize / 2
      } else {
        player.poolCurrent[i] = 0
      }

      let poolsInPoolType = pool.type.pools
      if(!poolsInPoolType) {
        poolsInPoolType = []
        pool.type.pools = poolsInPoolType
      }

      poolsInPoolType.push(pool)

      i++

    }

    player.poolCurrentPast = [ ...player.poolCurrent ]
    player.poolMaxPast = [ ...player.poolMax ]

    const growth = player.growth
    const growthSelection = player.growthSelection

    for(const key in growth) {
      growthSelection[key] = {}
    }

    for(const attribute in player.species.attributes) {
      growth.attributes[attribute] = 0
      growthSelection.attributes[attribute] = false
    }

    for(const poolName in pools) {
      growth.poolCapacity[poolName] = 0
      growthSelection.poolCapacity[poolName] = false
      growth.energyEfficiency[poolName] = 0
      growthSelection.energyEfficiency[poolName] = false
    }

    for(const channel of poolChannels) {
      const channelName = channel.name
      growth.channelMaxFlow[channelName] = 0
      growthSelection.channelMaxFlow[channelName] = false
    }

    for(const skill in skills) {
      growth.skills[skill] = 0
      growthSelection.skills[skill] = false
    }

  }

  getGameClock() {
    return this.backModel.gameClock
  }

  getCreatorMode() {
    return this.backModel.creatorMode
  }

  setCreatorMode() {
    this.backModel.creatorMode = true
  }

  getFloorItemsAt(pos) {
    const cell = this.getCell(pos)
    const floorItems = cell.onFloor
    return floorItems
  }

  handsUsed() {
    const hand = this.getPlayer().equip.hand
    let total = 0
    for(let i = 0; i < hand.length; i++) {
      total += hand[i].hands
    }
    return total
  }

  unequipItem(item) {

    const player = this.getPlayer()
    const slot = item.base.equipSlot
    let result = false

    switch(slot) {
      case 'hand':
      case 'ring':
        let list = player.equip[slot]
        let found = list.indexOf(item)
        if(found > -1) {
          list.splice(found, 1)
          result = true
        }
        break
      default:
        player.equip[slot] = null
        result = true
        break
    }
   
    return result

  }

  unequipUntilHandsFree(handsNeeded) {

    let result = true

    const player = this.getPlayer()
    const hand = player.equip.hand

    let handsAvailable = 
      player.species.hands 
      - this.handsUsed()

    while(handsAvailable < handsNeeded) {

      if(hand.length < 1) {
        result = false
        break
      }

      if(!unequipItem(hand[hand.length-1])) {
        result = false
        break
      }

      handsAvailable = 
        player.species.hands 
        - this.handsUsed()

    }

    return result

  }

  isEquipped(item) {
    const player = this.getPlayer()
    const slot = item.base.equipSlot
    let result = false
    if(slot == 'hand' || slot == 'ring') {
      let list = player.equip[slot]
      let found = list.indexOf(item)
      result = found > -1
    } else {
      result = player.equip[slot] == item
    }
    return result
  }

  equipItem(item) {

    const player = this.getPlayer()
    const slot = item.base.equipSlot

    if(!slot) {
      err(
        "Missing .equipSlot, can't equip: " 
        + getNameOf(null, item)
      )
    }

    // make sure it's not already there
    const alreadyThere = this.unequipItem(item)

    let result = false

    switch(slot) {
      case 'hand':
        if(!this.unequipUntilHandsFree(item.hands)) {
          break
        }
        player.equip[slot].unshift(item)
        result = true
        break
      case 'ring':
        if(player.equip[slot].length - player.species.hands < 1) {
          player.equip[slot].pop()
        }
        player.equip[slot].unshift(item)
        result = true
        break
      default: 
        player.equip[slot] = item
        result = true
        break
    }

    // don't charge time cost if the item was already equipped

    return result

  }

  dropItem(type, index, count) {
    const playerPos = this.getPlayerPos()
    const cell = this.getCell(playerPos)
    const item = this.removeItemFromInventoryByIndex(type, index, count)
    this.unequipItem(item)
    this.addSubjectToLevel(item, playerPos)
  }

  getEquipment() {
    return this.backModel.player.equip
  }

  getInventoryGroup(type) {
    return this.backModel.player.inventory[type]
  }

  addItemToInventory(item) {
    const type = item.base.type
    const group = this.getInventoryGroup(type)
    if(item.base.type == 'gold') {
      this.getPlayer().gold += item.count
    } else {
      let found = false
      for(let invItem of group) {
        if(itemsEqual(invItem, item)) {
          invItem.count += item.count
          found = true
          break
        }
      }
      if(!found) {
        group.push(item)
      }
    }
  }

  removeItemFromInventory(item, count) {
    const type = item.base.type
    const group = this.getInventoryGroup(type)
    let found = false
    let index
    for(index = 0; index < group.length; index++) {
      if(group[index] == item) {
        found = true
        break
      } 
    }
    if(!found) {
      err("Could not find item in inventory")
    }
    return this.removeItemFromInventoryByIndex(type, index, count)
  }

  removeItemFromInventoryByIndex(type, index, count) {

    const player = this.getPlayer()
    let item = player.inventory[type][index]
    const inventoryCount = item.count
    if(!count) {
      count = inventoryCount
    }

    if(count < 1) count = 1
    if(count > inventoryCount) count = inventoryCount

    if(count == inventoryCount) {
      player.inventory[type].splice(index, 1)
    } else {
      item.count -= count
      item = { ...item, count: count }
    }

    return item

  }

  getCell(pos) {
    return this.backModel.level[pos.x][pos.y]
  }

  adjacentCells(subjectPos) {
    let result = []
    const bm = this.backModel
    return subjectPos.adjacent(bm.levelSize)
  }

  buildLevel() {

    const bm = this.backModel
    const randomizer = this.getRandomizer('level')

    bm.level = generateLevelSimpleCaves(
      [], 
      bm.levelSize, 
      randomizer, 
      bm.levelCaveGenerator,
    )
    this.placeStuffInLevel(this.getRandomizer('item')) 

    const target = findEmptyCellCentrally(bm.level, randomizer)
    if(target == null) {
      err("Could not find an empty spot in the level to place the player.")
    }

    bm.level[target.x][target.y].occupiedBy = bm.player
    bm.player.pos = target

    const potion = this.generateItem(1, ['potion','experience'])
    this.addItemToInventory(potion)

  }

  generateItem(count, path, currentItem = template.generated) {

    const type = path.splice(0, 1)
    let newItem = currentItem.sub[type]
    if(!newItem) {
      err(
        'Could not find item to generate: ' 
        + type + ' from ' + currentItem.name
      )
    }

    if(path.length) {
      newItem = this.generateItem(count, path, newItem)
    } else {
      newItem = { base: newItem }
      if(count) {
        newItem.count = count
      }
    }

    return newItem

  }

  addActor(actor) {
    const bm = this.backModel
    bm.actor.push(actor)
  }

  removeActor(actor) {
    const bm = this.backModel
    bm.actor = bm.actor.filter(a => a != actor)
  }

  getActors() {
    return this.backModel.actor
  }

  countEmptyCells() {
    const bm = this.backModel
    const level = bm.level
    let emptyCellCount = 0
    for(let x = 0; x < level.length; x++) {
      for(let y = 0; y < level[0].length; y++) {
        let cell = level[x][y]
        if(cell.occupiedBy == null) {
          emptyCellCount++
        }
      }
    }

    debug("Found " + emptyCellCount + "/" + (level.length * level[0].length) + " empty cells")
    return emptyCellCount
  }
  
  pickSomethingToGenerate(group, randomizer) {
    let totalWeight = 0
    for(const [key, subject] of Object.entries(group)) {
      let weight = subject.chanceWeight
      if(weight == null) {
        err("Missing chanceWeight for " + getNameOf(null, subject))
      }
      totalWeight += weight

      subject.name = key
    }

    let selected = null
    let remainingWeight = randomizer.next(totalWeight)
    for(const subject of Object.values(group)) {
      let weight = subject.chanceWeight
      remainingWeight -= weight
      if(remainingWeight < 0) {
        selected = subject
        break
      }
    }

    // if(selected == null) {
    //   err("Failed to select subject")
    // }

    let result
    if(selected && selected.sub) {
      result = this.pickSomethingToGenerate(
        selected.sub, 
        randomizer,
      )
    } else {
      result = selected
    }

    return result
  }

  placeStuffInLevel(randomizer) {

    const bm = this.backModel
    const level = bm.level
    const stuffCount = Math.floor( 
      this.countEmptyCells() * template.generated.fillRatio
    )
    debug("Placing " + stuffCount + " things in this level.")

    let subject

    for(let n = 0; n < stuffCount; n++) {

      subject = this.pickSomethingToGenerate(
        template.generated.sub, 
        randomizer,
      )

      if(subject) {
        subject = { count: 1, base: subject, }
        let pos = findEmptyCellCentrally(level, randomizer)
        this.addSubjectToLevel(subject, pos)
        debug("Placed " + getNameOf(null, subject))
      }

    }

    subject = { 
      count: 1, 
      base: template.generated.sub.potion.sub.experience, 
    }
    let pos = findEmptyCellCentrally(level, randomizer)
    bm.experiencePotionInLevel = subject
    this.addSubjectToLevel(subject, pos)
    debug("Placed " + getNameOf(null, subject))

  }

  addSubjectToLevel(subject, pos) {

    const cell = this.getCell(pos)
    if(subject.base.act) {
      this.addActor(subject, pos)
    }

    if(subject.base.occupant) {

      cell.occupiedBy = subject

    } else {

      let found = false

      for(let floorItem of cell.onFloor) {
        if(itemsEqual(floorItem, subject)) {
          floorItem.count += subject.count
          found = true
          break
        }
      }

      if(!found) {
        cell.onFloor.push(subject)
      }

    }

    subject.pos = pos

    const glow = subject.base.glow
    if(glow) {
      const levelSize = this.getLevelSize()
      for(let x = pos.x - glow * 2; x < pos.x + glow * 2; x++) {
        for(let y = pos.y - glow * 2; y < pos.y + glow * 2; y++) {
          const target = new Pair(x, y)
          const distance = pos.distance(target)
          let amount = 0
          if(distance < glow) {
            amount = 2
          } else if(distance < glow * 2) {
            amount = 1
          }
          if(amount) {
            const wrappedTarget = target.wrap(levelSize)
            this.addCellGlow(wrappedTarget, amount)
          }
        }
      }
    }

  }

  removeSubjectFromLevel(subject, pos, count) {

    const bm = this.backModel
    const cell = this.getCell(pos)
    if(subject.base.act) {
      this.removeActor(subject)
    }

    let itemToReturn
    if(subject.base.occupant) {
      cell.occupiedBy = null
    } else {

      let index = cell.onFloor.findIndex(
        item => itemsEqual(item, subject)
      )
      let itemOnFloor = cell.onFloor[index]
      itemToReturn = itemOnFloor

      if(count == null) count = itemOnFloor.count
      if(count > itemOnFloor.count) count = itemOnFloor.count

      if(itemOnFloor.count == count) {
        cell.onFloor.splice(index, 1)
      } else {
        itemToReturn = { ...itemOnFloor, count: count }
        itemOnFloor.count -= count
      }

      if(bm.experiencePotionInLevel.base === subject.base
        && pos.equals(bm.experiencePotionInLevel.pos)) {
        bm.experiencePotionInLevel = null
      }

    }

    subject.pos = null

    const glow = subject.base.glow
    if(glow) {
      const levelSize = this.getLevelSize()
      for(let x = pos.x - glow * 2; x < pos.x + glow * 2; x++) {
        for(let y = pos.y - glow * 2; y < pos.y + glow * 2; y++) {
          const target = new Pair(x, y)
          const distance = pos.distance(target)
          let amount = 0
          if(distance < glow) {
            amount = 2
          } else if(distance < glow * 2) {
            amount = 1
          }
          if(amount) {
            const wrappedTarget = target.wrap(levelSize)
            this.addCellGlow(wrappedTarget, -amount)
          }
        }
      }
    }

    return itemToReturn

  }

  getLevel() {
    return this.backModel.level
  }

  getLevelSize() {
    return this.backModel.levelSize
  }

  getPlayer() {
    return this.backModel.player
  }

  getPlayerPos() {
    return this.backModel.player.pos
  }

  getPlayerSpecies() {
    return this.backModel.player.species
  }

  isFieldPosValid(cellPos) {
    return cellPos.within(emptyPair, this.backModel.levelSize)
  }

  isFieldPosOccupied(cellPos) {
    return this.backModel.level[cellPos.x][cellPos.y].occupiedBy != null
  }

}

class FrontController {

  constructor() {
    let fm = _.cloneDeep(template.frontModel)
    this.frontModel = fm

    for(const [screenName, screen] of Object.entries(screens)) {
      for(const [windowName, window] of Object.entries(screen.window)) {
        window.name = windowName
        let size = window.size.multiply(screen.cellPixelDimensions)
        size = size.divide(window.cellPixelDimensions).floor()
        window.smallCellSize = size
      }
      screen.name = screenName
    }

    this.inController = new InController()
    this.outController = new OutController()
  }

  checkPan(window, pos, size) {
    if(window == screens.main.window.level) {
      this.adjustLevelPan(window, pos, size)
    }
  }

  adjustLevelPan(levelWindow, pos, levelSize) {

    const windowSize = levelWindow.size

    levelWindow.panCellOffset = 
      pos
        .subtract(
          windowSize.divide(pair(2)).floor()
        )
        .wrap(levelSize)

    this.setLevelChanged(true)

  }

  outputCreatorModeMessages() {
    this.addMessage(
      keyMap.creator.creatorRegenLevel 
    + ' - regenerate level'
    )
    this.addMessage(
      keyMap.creator.creatorSetEnergy 
    + ' - set energy'
    )
    this.addMessage(
      keyMap.creator.creatorSetSkill 
    + ' - set skill'
    )
    this.addMessage(
      keyMap.creator.creatorAdvanceLevel 
    + ' - advance experience level'
    )
    this.addMessage(
      keyMap.creator.creatorAwakenPool
    + ' - awaken pool'
    )
  }

  editGrowthAllocationSelectCategory_addCategory(
    key, name, title, subject,
    names, subjects, keys, growthSelection
  ) {

    const [ selected, total ] = 
      getGrowthSelectCount(growthSelection[name])

    names.push(
      name + ' (' 
    + selected 
    + '/'
    + total
    + ' selected)'
    )

    subjects.push(subject)

    keys.push(key)

  }

  editGrowthAllocationSelectCategory(
    growthSelection,
    growthPerLevel
  ) {
    
    const [growthSelectCount, _] = 
      getGrowthSelectCount(growthSelection)

    this.resetSelect()
    this.setSelectTitle(
      () =>
      'Choose growth category: (' 
    + growthSelectCount 
    + '/' 
    + growthPerLevel 
    + ' growth points used)'
    )

    let names = []
    let subjects = []
    let keys = []

    this.editGrowthAllocationSelectCategory_addCategory(
      'a', 'attributes', 'attributes', 
      () => { 
        topController.editGrowthAllocationSelectAttributes() 
      },
      names, subjects, keys, growthSelection,
    )

    this.editGrowthAllocationSelectCategory_addCategory(
      'p', 'poolCapacity', 'pool capacity', 
      () => { 
        topController.editGrowthAllocationSelectPoolCapacity() 
      },
      names, subjects, keys, growthSelection,
    )

    this.editGrowthAllocationSelectCategory_addCategory(
      'e', 'energyEfficiency', 'energy efficiency',
      () => { 
        topController.editGrowthAllocationSelectEnergyEfficiency() 
      },
      names, subjects, keys, growthSelection,
    )

    this.editGrowthAllocationSelectCategory_addCategory(
      'c', 'channelMaxFlow', 'channel max flow',
      () => { 
        topController.editGrowthAllocationSelectChannelMaxFlow() 
      },
      names, subjects, keys, growthSelection,
    )

    this.editGrowthAllocationSelectCategory_addCategory(
      's', 'skills', 'skills',
      () => { 
        topController.editGrowthAllocationSelectSkills() 
      },
      names, subjects, keys, growthSelection,
    )

    this.setSelectNameList(names)
    this.setSelectSubjectList(subjects)
    this.setSelectKeys(keys)
    this.setKeyMode('select')

    this.setSelectAction(() => {
      topController.editGrowthAllocationSelect()
    })

    this.setSelectExecute(() => {
      topController.exitSimple()
    })

    this.showSelectedItems()

  }

  editGrowthAllocationSelect() {
    const action = this.getSelectedSubject()
    action()
  }

  getStatusMode() {
    return this.frontModel.statusMode
  }

  changeStatusMode() {
    const fm = this.frontModel
    if(fm.statusMode == 'compact') {
      fm.statusMode = 'expanded'
    } else {
      fm.statusMode = 'compact'
    }
    this.setStatusChanged(true)
  }

  willpowerFocusSelectFocusType() {
    const names = [ 'pool', 'sense' ]
    const keys = [ 'p', 's' ]
    this.resetSelect()
    this.setSelectTitle(() => 'Choose focus type:')
    this.setSelectNameList(names)
    this.setSelectKeys(keys)
    this.setSelectAllowMultiple(false)
    this.setKeyMode('select')
    this.setSelectAction(() => {
      topController.afterWillpowerFocusSelectFocusType()
    })
    this.showSelectedItems()
  }

  willpowerFocusSelectPoolType() {
    this.selectPoolType(
      () => { topController.willpowerFocusSelectPool() },
      false,
    )
  }

  willpowerFocusSelectSense() {

    let names = []
    let subjects = []
    let keys = []

    for(let sense of Object.values(senses)) {
      names.push(sense.name)
      keys.push(sense.key)
      subjects.push(sense)
    }

    this.resetSelect()
    this.setSelectTitle(() => 'Choose sense:')
    this.setSelectNameList(names)
    this.setSelectSubjectList(subjects)
    this.setSelectKeys(keys)
    this.setSelectAllowMultiple(false)
    this.setKeyMode('select')
    this.setSelectAction(() => {
      topController.willpowerFocusExecute()
    })
    this.showSelectedItems()

  }

  channelCommandSelectPoolType() {
    this.selectPoolType(
      () => { topController.channelCommandSelectPool() },
      true,
    )
  }

  selectSkill(afterSelect, allowMultiple) {

    let names = []
    let subjects = []

    for(let skill of Object.values(skills)) {
      names.push(skill.name)
      subjects.push(skill)
    }

    this.resetSelect()
    this.setSelectTitle(
      (multi) => {
        if(multi) return 'Choose skills:'
        return 'Choose skill:'
      }
    )
    this.setSelectNameList(names)
    this.setSelectSubjectList(subjects)
    this.setSelectAllowMultiple(allowMultiple)
    this.setSelectCountMax(999)
    this.setKeyMode('select')

    this.setSelectAction(afterSelect)

    this.showSelectedItems()

  }
  
  selectPoolType(afterSelect, allowMultiple) {

    let names = []
    let subjects = []
    let keys = []

    for(let poolType of Object.values(poolTypes)) {
      names.push(poolType.name)
      keys.push(poolType.key)
      subjects.push(poolType.pools)
    }

    this.resetSelect()
    this.setSelectTitle(
      (multi) => {
        if(multi) return 'Choose pool types:'
        return 'Choose pool type:'
      }
    )
    this.setSelectNameList(names)
    this.setSelectSubjectList(subjects)
    this.setSelectKeys(keys)
    this.setSelectAllowMultiple(allowMultiple)
    this.setKeyMode('select')

    this.setSelectAction(afterSelect)

    this.showSelectedItems()

  }
  
  creatorModeSetEnergySelectPool() {
    this.selectPool(
      () => { topController.creatorModeSetEnergyGetAmount() },
      false,
    )
  }

  creatorModeSetEnergyGetAmount() {
    this.selectAmount(
      () => { topController.creatorModeSetEnergyExecute() },
    )
  }

  willpowerFocusSelectPool() {
    this.selectPool(
      () => { topController.willpowerFocusExecute() },
      false,
    )
  }

  channelCommandSelectPool() {
    this.selectPool(
      () => { topController.channelCommandSelectChannel() },
      true,
    )
  }

  selectAmount(afterSelect) {

    let names = []
    let keys = []
    let subjects = []

    this.setSelectMeta('subjects', this.getSelectedSubjects())

    names.push('full')
    keys.push('f')
    subjects.push(1)

    names.push('half')
    keys.push('h')
    subjects.push(0.5)

    names.push('empty')
    keys.push('e')
    subjects.push(0)

    this.resetSelect()
    this.setSelectTitle(() => 'Choose amount:')

    this.setSelectNameList(names)
    this.setSelectKeys(keys)
    this.setSelectSubjectList(subjects)
    this.setSelectAllowMultiple(false)
    this.setKeyMode('select')

    this.setSelectAction(afterSelect)
    this.setSelectExecute(afterSelect)

    this.showSelectedItems()

  }

  selectPool(afterSelect, allowMultiple) {

    let names = []
    let subjects = []
    let keys = []

    let poolTypes = this.getSelectedSubjects()

    if(poolTypes.length == 0) {
      err("No pool groups selected. This shouldn't happen")
    }

    if(poolTypes.length > 1) {
      // if multiple pool types were chosen, we can't
      // list the pools that are part of them, since they
      // will have conflicting keys. So we will just assume
      // the player wants all pools in each of the types
      // chosen, and will skip this selection step
      let indexes = []
      for(let pt = 0; pt < poolTypes.length; pt++) {
        const poolTypePools = poolTypes[pt]
        for(let p = 0; p < poolTypePools.length; p++) {
          const pool = poolTypePools[p]
          for(let c = 0; c < pool.channelIndexes.length; c++) {
            const channelIndex = pool.channelIndexes[c]
            if(!subjects.includes(channelIndex)) {
              subjects.push(channelIndex)
              indexes.push(true)
            }
          }
        }
      }
      this.setSelectSubjectList(subjects)
      this.setSelectFlags(indexes)
      topController.channelCommandSelectFlow()
      return
    }

    // only one pool type was selected, so we can list the
    // pools of this type for the user to select from

    let subjectPools = poolTypes[0]

    for(let pool of Object.values(subjectPools)) {
      names.push(pool.name)
      keys.push(pool.key)
      subjects.push(pool)
    }

    this.resetSelect()
    this.setSelectTitle(
      (multi) => {
        if(multi) return 'Choose pools:'
        return 'Choose pool:'
      }
    )

    this.setSelectNameList(names)
    this.setSelectSubjectList(subjects)
    this.setSelectKeys(keys)
    this.setSelectAllowMultiple(allowMultiple)
    this.setKeyMode('select')

    this.setSelectAction(afterSelect)

    this.showSelectedItems()

  }

  channelCommandSelectFlow() {

    let names = []
    let keys = []
    let subjects = this.getSelectedSubjects()
    this.setSelectMeta('channelIndexes', subjects)

    if(subjects.length == 0) {
      err("No channels selected. This shouldn't happen")
    }

    for(let i = 9; i >= 0; i--) {
      keys.push('' + i)
      let percentage
      if(i > 6) {
        percentage = Math.floor(
          getChannelFlowFromMagnitude(i, 100)
        )
      } else if(i > 3) {
        percentage = Math.floor(
          getChannelFlowFromMagnitude(i, 1000)
        ) / 10
      } else if(i > 1) {
        percentage = Math.floor(
          getChannelFlowFromMagnitude(i, 10000)
        ) / 100
      } else {
        percentage = Math.floor(
          getChannelFlowFromMagnitude(i, 100000)
        ) / 1000
      }
      names.push(percentage + '%')
    }

    this.resetSelect()

    this.setSelectTitle(
      () => 'Choose how open the selected channels should be:'
    )

    this.setSelectNameList(names)
    this.setSelectAllowMultiple(false)
    this.setSelectKeys(keys)
    this.setKeyMode('select')

    this.setSelectAction(
      () => { topController.channelCommandExecuteChange() }
    )

    this.showSelectedItems()

  }

  drawMessagesWindow(screen, window) {

    const fm = this.frontModel
    const messages = fm.messages
    const header = fm.messagesHeader
    const maxMessageRow = window.smallCellSize.y - 1
    let xOffset = 0
    let yOffset = 0
    let maxWidth = 0

    for(let row = 0; row < messages.length; row++) {

      let message = messages[row]
      if(message == null) {
        err("Bad message")
      }
      let effectiveRow = row + yOffset

      if(effectiveRow > maxMessageRow) {
        xOffset += maxWidth + 3
        yOffset -= maxMessageRow - header + 1
        effectiveRow = row + yOffset
        maxWidth = 0
      }

      this.drawText({
        screen: screen, 
        window: window, 
        windowPos: new Pair(xOffset, effectiveRow), 
        textToDraw: message,
        centerX: false,
        centerY: false,
        textOffset: new Pair(0, -3),
      })

      if(row > header - 1) {
        maxWidth = Math.max(maxWidth, message.length)
      }

    }
      
  }

  drawStatusWindow(screen, window, statusList) {
    let xOffset = 0
    let yOffset = 0
    const maxRow = screens.main.window.status.smallCellSize.y - 1
    const halfWidth = 
      Math.floor(screens.main.window.status.smallCellSize.x / 2)
    for(let row = 0; row < statusList.length; row++) {
      let effectiveRow = row + yOffset
      let statusRow = statusList[row]
      if(effectiveRow > maxRow) {
        yOffset -= maxRow
        xOffset += halfWidth
        effectiveRow = row + yOffset
      }
      this.drawText({
        screen: screen, 
        window: window, 
        windowPos: new Pair(xOffset, effectiveRow), 
        textToDraw: statusRow,
        maxColumns: window.smallCellSize.x / 2,
        centerX: false,
        centerY: false,
        textOffset: new Pair(0, -3),
      })
    }
  }

  setMotionMode(mode) {
    this.frontModel.motionMode = mode
    this.setStatusChanged(true)
  }

  motionModeAttack() {
    const mode = this.frontModel.motionMode
    return mode == 'attack' || mode == 'attackOrMove'
  }

  motionModeMove() {
    const mode = this.frontModel.motionMode
    return mode == 'move' || mode == 'attackOrMove'
  }

  getTarget() {
    return this.frontModel.target
  }

  setTarget(pos) {
    this.frontModel.target.pos = pos
    this.setLevelChanged(true)
  }

  clearNumericSelection() {
    if(this.frontModel.selectCount != null) {
      this.frontModel.selectCount = null
    } else {
      fill(this.frontModel.selectFlags, false)
    }
    this.showSelectedItems()
  }

  selectItem(key) {

    const fm = this.frontModel
    const keyInt = parseInt(key)

    if(
      Number.isInteger(keyInt) 
      && (
        fm.selectCountMaxList.length
        || fm.selectCountMax != null
      )
    ) {

      if(fm.selectCount) {
        fm.selectCount = fm.selectCount * 10 + keyInt
      } else {
        fm.selectCount = keyInt
      }

      this.showSelectedItems()

    } else {

      const items = fm.selectNameList
      if(items.length == 0) {
        return
      }

      let index
      if(fm.selectKeys.length > 0) {
        index = fm.selectKeys.findIndex(x => x == key)
      } else {
        index =  this.keyToIndex(key)
      }

      if(
        index < 0 
        || index >= fm.selectNameList.length
        // this seems to cause problems, not sure we even need it
        // || fm.selectSubjectList[index] == null
      ) {
        this.addMessage("Invalid item.")
        this.showSelectedItems()
        return
      }

      this.toggleSelectedItem(index)
      if(fm.selectMultiple) {
        this.showSelectedItems()
      } else {
        fm.selectAction()
      }

    }

  }

  clearSelectMeta(key) {
    this.frontModel.selectMeta = {}
  }

  getSelectMeta(key) {
    return this.frontModel.selectMeta[key]
  }

  setSelectMeta(key, value) {
    this.frontModel.selectMeta[key] = value
  }

  setSelectTitle(titleFunction) {
    this.frontModel.selectTitle = titleFunction
  }

  getSelectAllowMultiple(allow) {
    return this.frontModel.selectAllowMultiple
  }

  setSelectAllowMultiple(allow) {
    this.frontModel.selectAllowMultiple = allow
  }

  setSelectMultiple(multiple) {
    this.frontModel.selectMultiple = multiple
  }

  getSelectExecute() {
    return this.frontModel.selectExecute
  }

  setSelectExecute(action) {
    this.frontModel.selectExecute = action
  }

  getSelectAction(action) {
    return this.frontModel.selectAction
  }

  setSelectAction(action) {
    this.frontModel.selectAction = action
  }

  setSelectCountMaxList(list) {
    this.frontModel.selectCountMaxList = list
  }

  setSelectNameList(list) {
    const fm = this.frontModel
    fm.selectNameList = list
    if(fm.selectFlags == null) {
      fm.selectFlags = new Array(list.length).fill(false)
    }
  }

  setSelectKeys(list) {
    this.frontModel.selectKeys = list
  }

  setSelectSubjectList(list) {
    this.frontModel.selectSubjectList = list
  }

  setSelectFlags(indexes) {
    this.frontModel.selectFlags = indexes
  }

  isIndexSelected(index) {
    return Object.values(this.frontModel.selectFlags)[index] 
  }

  invertMultiSelect() {
    const fm = this.frontModel
    fm.selectMultiple = !fm.selectMultiple
  }

  invertSelectedItems() {
    const fm = this.frontModel
    const selected = fm.selectFlags
    fm.selectMultiple = true
    for(let key in selected) {
      if(selected[key]) {
        selected[key] = false
      } else {
        selected[key] = true
      }
    }
  }

  resetSelect() {
    const fm = this.frontModel
    fm.selectAction = null
    fm.selectExecuteAction = null
    fm.selectAllowMultiple = true
    fm.selectCount = null
    fm.selectCountList = []
    fm.selectCountMaxList = []
    fm.selectCountMax = null
    fm.selectFlags = null
    fm.selectKeys = []
    fm.selectMultiple = false
    fm.selectNameList = []
    fm.selectSubjectList = []
    fm.selectTitle = []
    fm.selectMaxWidth = null
    fm.selectAfterChange = null
    // not resetting meta. That's supposed to persist between calls.
    // fm.selectMeta = {}
  }

  setSelectMaxWidth(maxWidth) {
    this.frontModel.selectMaxWidth = Math.floor(maxWidth)
  }

  getSelectedIndexes() {
    const fm = this.frontModel
    let indexes = [];
    const selectFlagsList = Object.values(fm.selectFlags)
    for(let i in selectFlagsList) {
      if(selectFlagsList[i]) {
        indexes.push(i)
      }
    }
    return indexes
  }

  getSelectedIndex() {
    const fm = this.frontModel
    let found = -1;
    const selectFlagsList = Object.values(fm.selectFlags)
    for(let i = 0; i < selectFlagsList.length; i++) {
      if(selectFlagsList[i]) {
        found = i
        break
      }
    }
    return found
  }

  getSelectedKeys() {
    const fm = this.frontModel
    let selectedKeys = []
    for(let i of this.getSelectedIndexes()) {
      selectedKeys.push(fm.selectKeys[i])
    }
    return selectedKeys
  }

  getSelectedSubjectsAndCounts() {
    const fm = this.frontModel
    let selectedSubjects = []
    let selectedCounts = []
    for(let i of this.getSelectedIndexes()) {
      selectedSubjects.push(fm.selectSubjectList[i])
      selectedCounts.push(fm.selectCountList[i])
    }
    return [selectedSubjects, selectedCounts]
  }

  getSelectedSubjects() {
    return this.getSelectedSubjectsAndCounts()[0]
  }

  getSelectedSubject() {
    const selectedSubjects = this.getSelectedSubjects()
    if(selectedSubjects && selectedSubjects.length > 0) {
      return this.getSelectedSubjects()[0]
    } else {
      return null
    }
  }

  setSelectCountMax(value) {
    this.frontModel.selectCountMax = value
  }

  getSelectCount() {
    return this.frontModel.selectCount
  }

  getSelectCountByIndex(index) {
    return this.frontModel.selectCountList[index]
  }

  toggleSelectedItem(index) {

    const fm = this.frontModel

    if(index < 0) return

    let i = 0
    // this more complicated way enables us to
    // handle selectFlags being an array OR an object
    for(let key in fm.selectFlags) {
      if(i == index) {
        const selected = fm.selectFlags[key]
        if(selected) {
          fm.selectCountList[index] = 0
          fm.selectFlags[key] = false
        } else {
          let count = fm.selectCount
          if(count == null) {
            count = fm.selectCountMaxList[index] || 1
          }
          fm.selectCountList[index] = count
          fm.selectFlags[key] = true
        }
        break
      }
      i++
    }

  }

  showSelectedItems() {

    const fm = this.frontModel

    let message = fm.selectTitle(fm.selectMultiple, fm.selectFlags)
    if(fm.selectCount) message += ' ' + fm.selectCount
    this.addMessage(message)

    const items = fm.selectNameList
    const keys = fm.selectKeys

    for(let i = 0; i < items.length; i++) {

      let key = keys[i]
      if(!key) {
        key = this.indexToKey(i)
      }

      let selected = this.isIndexSelected(i) 

      selected = selected ? ' + ' : ' - '
      const name = items[i]
      let count = ''
      const maxCount = fm.selectCountMaxList[i]

      if(maxCount > 1) {
        let selectedCount = fm.selectCountList[i]
        if(selectedCount == null) selectedCount = 0
        count = '[' + selectedCount + '/' + maxCount + '] '
      }

      let prefix = key + selected + count
      if(typeof name == 'string') {

        let remaining = name
        let fits
        const maxWidth = fm.selectMaxWidth 
          || screens.main.window.message.smallCellSize.x

        while(prefix.length + remaining.length >= maxWidth) {
          [ fits, remaining ] = 
            splitAtBlankBefore(remaining, maxWidth - prefix.length)
          if(fits.length == 0 || remaining.length == 0) break
          this.addMessage(prefix + fits, true)
          prefix = '    '
        }

        this.addMessage(prefix + remaining, true)

      } else {

        let remaining = name
        let fits
        const maxWidth = fm.selectMaxWidth 
          || screens.main.window.message.smallCellSize.x

        while(prefix.length + complexLength(remaining) 
          >= maxWidth
        ) {

          [ fits, remaining ] = 
            splitAtBlankBefore(remaining, maxWidth - prefix.length)

          if(complexLength(fits) == 0 
            || complexLength(remaining) == 0
          ) break

          this.addMessage([ 
            text(prefix), 
            ...complexJoin(fits),
          ], true)
          prefix = '    '

        }

        this.addMessage([ 
          text(prefix), 
          ...complexJoin(remaining),
        ], true)

      }

    }
    
  }

  executeAction() {

    const fm = this.frontModel

    const subject = this.getSelectedSubject()

    if(subject == null) {
      this.addMessage('Unknown action.')
      this.showInventoryActions()
    }

    const items = subject.items
    const counts = subject.counts
    const action = subject.action

    for(let i = 0; i < items.length; i++) {
      action.execute(
        items[i],
        counts[i] || 1,
      )
    }

  }

  showInventoryActions() {

    const fm = this.frontModel
    const [items, counts] = this.getSelectedSubjectsAndCounts()

    let subjects = []
    const actions = getActionsFor(
      items[0].base.type,
      items.length > 1,
    )

    let names = []
    let keys = []
    for(let action of actions) {
      names.push(action.name)
      subjects.push({ action: action, items: items, counts: counts })
      keys.push(action.key)
    }

    this.resetSelect()
    this.setSelectNameList(names)
    this.setSelectSubjectList(subjects)
    this.setSelectKeys(keys)
    this.setSelectAllowMultiple(false)
    this.setSelectTitle(() => 'Choose an action:')

    this.setSelectAction(
      () => { topController.executeAction() }
    )

    this.showSelectedItems()

  }

  showInventoryGroup(inventoryGroup) {
    this.resetSelect()
    this.setSelectNameList(
      inventoryGroup.map(
        item => getNameOf(null, item)
      )
    )
    this.setSelectSubjectList(inventoryGroup)
    this.setSelectTitle(
      (multi) => {
        if(multi) return 'Choose items:'
        return 'Choose item:'
      }
    )
    this.setSelectAction(
      () => { topController.showInventoryActions() }
    )
    this.setSelectCountMaxList(
      inventoryGroup.map(
        item => item.count
      )
    )
    this.showSelectedItems()
  }

  keyToIndex(key) {
    const code = key.charCodeAt(0)
    let offset = -1
    if(
         code >= 'a'.charCodeAt(0) && code <= 'z'.charCodeAt(0)
      || code >= 'A'.charCodeAt(0) && code <= 'Z'.charCodeAt(0)
    ) {
      offset = code - 97
      if(offset < 0) offset = code - 65 + 26
    }
    return offset
  }

  indexToKey(index) {
    let offset = index + 97
    if(index >= 26) offset = index + 65 - 26
    const c = String.fromCharCode(offset)
    return c
  }

  addMessage(message, multiColumn = false) {
    const fm = this.frontModel
    fm.messages.push(message)
    if(!multiColumn) {
      fm.messagesHeader = fm.messages.length
    }
    fm.messagesChanged = true
  }

  setLevelChanged(changed) {
    this.frontModel.levelChanged = changed
  }

  getLevelChanged() {
    return this.frontModel.levelChanged 
  }

  getLevelCellsChanged() {
    return this.frontModel.levelCellsChanged
  }

  addLevelCellsChanged(pos) {
    return this.frontModel.levelCellsChanged.push(pos)
  }

  clearLevelCellsChanged() {
    return this.frontModel.levelCellsChanged = []
  }

  setMessagesChanged(changed) {
    this.frontModel.messagesChanged = changed
  }

  getMessagesChanged() {
    return this.frontModel.messagesChanged 
  }

  setStatusChanged(changed) {
    this.frontModel.statusChanged = changed
  }

  getStatusChanged() {
    return this.frontModel.statusChanged 
  }

  clearMessages() {
    const fm = this.frontModel
    if(fm.messages.length) {
      fm.messages = []
      fm.messagesChanged = true
    }
  }

  setScreen(screenName) {
    this.frontModel.currentScreen = screenName
  }

  levelPosToWindowPos(levelPos, levelSize) {
    const window = screens.main.window.level
    const panOffset = window.panCellOffset
    return levelPos.subtract(panOffset).wrap(levelSize)
  }

  getKeyMode() {
    return this.frontModel.currentKeyMode
  }

  setKeyMode(keyModeName) {
    this.frontModel.currentKeyMode = keyModeName
  }

  windowCellPosToScreenPixelPos(screen, window, windowPos) {
    const screenPixelPos = window.pos.multiply(
      screen.cellPixelDimensions
    )
    const windowPixelPos = windowPos.multiply(
      window.cellPixelDimensions
    )
    return screenPixelPos.add(windowPixelPos)
  }

  windowCellPosToLevel(window, windowCellPos, levelSize) {
    return windowCellPos
      .add(window.panCellOffset)
      .wrap(levelSize)
  }

  clearWindow(screen, window) {
    const screenPixelPos = this.windowCellPosToScreenPixelPos(
      screen,
      window,
      emptyPair,
      )

    this.outController.clearRect(
      new Rect(
        screenPixelPos.x - 1, 
        screenPixelPos.y - 1, 
        screenPixelPos.x + window.size.x * screen.cellPixelDimensions.x + 1, 
        screenPixelPos.y + window.size.y * screen.cellPixelDimensions.y + 1,
      )
    )
  }

  windowToWindowName(screen, window) {

    let windowName

    for(const [testName, testWindow] of Object.entries(screen.window)) {
      if(testWindow == window) {
        windowName = testName
      }
    }

    return windowName

  }

  getActionModeMessage() {

    const fm = this.frontModel
    let actionMode = fm.motionMode
    let actionMessage = 'Unknown'

    if(actionMode == 'attackOrMove') {
      actionMessage = 'Move / Attack'
    } else if(actionMode == 'move') {
      actionMessage = 'Move'
    } else if(actionMode == 'attack') {
      actionMessage = 'Attack'
    } 

    return actionMessage

  }

  getCellPixelRect(screen, window, windowPos) {
    const posUpperLeft = this.windowCellPosToScreenPixelPos(screen, window, windowPos)
    const posLowerRight = posUpperLeft.add(window.cellPixelDimensions)
    return new Rect(posUpperLeft.x, posUpperLeft.y, posLowerRight.x, posLowerRight.y)
  }

  getWindowPixelRect(screen, window) {
    const posUpperLeft = this.windowCellPosToScreenPixelPos(screen, window, emptyPair)
    const posLowerRight = posUpperLeft.add(window.size.multiply(window.cellPixelDimensions))
    return new Rect(posUpperLeft.x, posUpperLeft.y, posLowerRight.x, posLowerRight.y)
  }

  drawCenterLines(screen, window, levelSize) {

    const baselinePos = 
      this.levelPosToWindowPos(emptyPair, levelSize)
    let cellBoundary = 
      this.getCellPixelRect(
        screen, window, baselinePos
      ).add(new Pair(0,-1))
    const windowBoundary = this.getWindowPixelRect(screen, window)

    const thickness = 0
    let style = "#8080FF40"

    if(baselinePos.x < window.size.x) {
      this.outController.drawEmptyRect(
        new Rect(
          cellBoundary.x1 - thickness, 
          windowBoundary.y1, 
          cellBoundary.x1 + thickness,
          windowBoundary.y2,
        )
        , style
      )
    }

    if(baselinePos.y < window.size.y) {
      this.outController.drawEmptyRect(
        new Rect(
          windowBoundary.x1, 
          cellBoundary.y1 - thickness, 
          windowBoundary.x2,
          cellBoundary.y1 + thickness,
        )
        , style
      )
    }

    const midlinePos = 
      this.levelPosToWindowPos(levelSize.divide(2), levelSize)

    cellBoundary = 
      this.getCellPixelRect(
        screen, window, midlinePos
      ).add(new Pair(0,-1))
    style = "#FF808040"

    if(midlinePos.x < window.size.x) {
      this.outController.drawEmptyRect(
        new Rect(
          cellBoundary.x1 - thickness, 
          windowBoundary.y1, 
          cellBoundary.x1 + thickness,
          windowBoundary.y2,
        )
        , style
      )
    }

    if(midlinePos.y < window.size.y) {
      this.outController.drawEmptyRect(
        new Rect(
          windowBoundary.x1, 
          cellBoundary.y1 - thickness, 
          windowBoundary.x2,
          cellBoundary.y1 + thickness,
        )
        , style
      )
    }

  }

  drawTarget(screen, window, targetPos, levelSize) {
    const windowPos = 
      this.levelPosToWindowPos(targetPos, levelSize)
    const cellBoundary = 
      this.getCellPixelRect(
        screen, window, windowPos
      ).add(new Pair(0,-1))
    const windowBoundary = 
      this.getWindowPixelRect(screen, window)
    const yMid = (cellBoundary.y1 + cellBoundary.y2) / 2
    const xMid = (cellBoundary.x1 + cellBoundary.x2) / 2
    const thickness = 2
    const style = "#0000C080"
    const heavyStyle = "#0000C0"
    this.outController.drawEmptyRect(
      new Rect(windowBoundary.x1, yMid - thickness, cellBoundary.x1, yMid + thickness)
      , style
    )
    this.outController.drawEmptyRect(
      new Rect(cellBoundary.x2, yMid - thickness, windowBoundary.x2, yMid + thickness)
      , style
    )
    this.outController.drawEmptyRect(
      new Rect(xMid - thickness, windowBoundary.y1, xMid + thickness, cellBoundary.y1)
      , style
    )
    this.outController.drawEmptyRect(
      new Rect(xMid - thickness, cellBoundary.y2, xMid + thickness, windowBoundary.y2)
      , style
    )
    this.outController.drawEmptyRect(cellBoundary, heavyStyle)
  }

  windowPosIsValid(window, windowPos) {
    return windowPos.x >= 0 
      && windowPos.y >= 0
      && windowPos.x < window.size.x
      && windowPos.y < window.size.y
  }

  clearWindowCells(screen, window, cells) {
    for(const cellPos of cells) {
      if(this.windowPosIsValid(window, cellPos)) {
        const screenPixelPos = this.windowCellPosToScreenPixelPos(
          screen,
          window,
          cellPos,
          )

        this.outController.clearRect(
          new Rect(
            screenPixelPos.x, 
            screenPixelPos.y, 
            screenPixelPos.x + screen.cellPixelDimensions.x, 
            screenPixelPos.y + screen.cellPixelDimensions.y,
          )
        )
      }
    }
  }

  getFontStyle(screen, window) {
    if(window.fontStyle) {
      return window.fontStyle
    }

    if(screen.fontStyle) {
      return screen.fontStyle
    }

    if(this.frontModel.fontStyle) {
      return this.frontModel.fontStyle
    }

    return fontStyle.fixed
  }

  // accepts an object with the following props:
  //  screen, 
  //  window, 
  //  windowPos, 
  //  textToDraw = null, 
  //  offset = null, 
  //  textOffset = null,
  //  centerX = false,
  //  centerY = false,
  //  maxColumns = null,
  drawText(p) {

    const cellSizePixels = p.window.cellPixelDimensions
    const fontStyle = this.getFontStyle(p.screen, p.window)
    const screenPixelPos = this.windowCellPosToScreenPixelPos(
      p.screen,
      p.window,
      p.windowPos
    )

    if(p.window.offset) {
      p.offset = p.window.offset.add(p.offset)
    }

    this.outController.drawText({
      fontStyle: fontStyle, 
      screenPixelPos: screenPixelPos, 
      textToDraw: p.textToDraw, 
      offset: p.offset, 
      centerX: p.centerX, 
      centerY: p.centerY, 
      cellSizePixels: cellSizePixels,
      maxColumns: p.maxColumns,
      textOffset: p.textOffset,
    })

  }

  getCurrentScreen() {
    const cs = this.frontModel.currentScreen
    const screen = screens[cs]
    return screen
  }

}

let keyModifiers = {
  alt: false,
  command: false,
  control: false,
  shift: false,
}

class InController {

  constructor() {
    document.removeEventListener("keyup", this.handleKeyUp, false)
    document.addEventListener("keyup", this.handleKeyUp, false)
    document.removeEventListener("keydown", this.handleKeyDown, false)
    document.addEventListener("keydown", this.handleKeyDown, false)
  }

  handleKeyDown(event) {
    switch(event.key) {
      case 'Alt':
        keyModifiers.alt = true
        break
      case 'Meta':
        keyModifiers.command = true
        break
      case 'Control':
        keyModifiers.control = true
        break
      case 'Shift':
        keyModifiers.shift = true
        break
    }
  }

  handleKeyUp(event) {
    switch(event.key) {
      case 'Alt':
        keyModifiers.alt = false
        return
      case 'Meta':
        keyModifiers.command = false
        return
      case 'Control':
        keyModifiers.control = false
        return
      case 'Shift':
        keyModifiers.shift = false
        return
    }

    topController.beforeEachTurn()

    const km = topController.getKeyMode()

    for(let command of Object.keys(keyMap[km])) {
      if(keyMap[km][command].some(x => event.key == x)) {
        commandExecution[command]()
        break
      } else if(keyMap[km][command].length == 0) {
        commandExecution[command](event.key)
        break
      }
    }

    topController.afterEachTurn()
  }

}

class OutController {

  constructor() {
    this.previousFontStyle = null
    this.previousFillStyle = null
  }

  // accepts an object with the following props:
  //  fontStyle, 
  //  screenPixelPos, 
  //  textToDraw = null, 
  //  offset = null, 
  //  textOffset = null,
  //  centerX = false,
  //  centerY = false,
  //  cellSizePixels = null,
  //  maxColumns = null,
  drawText(p) {

    let multipleColumnBlocks = false
    if(typeof p.textToDraw == 'string') {
      p.textToDrawList = [text(p.textToDraw)]
    } else {
      p.textToDrawList = p.textToDraw
      if(p.textToDrawList.length > 1) {
        multipleColumnBlocks = true
      }
    }

    let textOffset = p.textOffset || emptyPair

    for(let i = 0; i < p.textToDrawList.length; i++) {

      const textToDrawObject = p.textToDrawList[i]
      const textToDraw = textToDrawObject.text
      const style = textToDrawObject.style || '#000000'
      const bgStyle = textToDrawObject.bgStyle

      let maxSize
      if(multipleColumnBlocks) {
        maxSize = textToDraw.length * p.cellSizePixels.x
      } else {
        maxSize = p.maxColumns * p.cellSizePixels.x
      }

      let xOffset = canvasProps.xOffset 
      let yOffset = canvasProps.yOffset

      if(p.offset) {
        xOffset += p.offset.x
        yOffset += p.offset.y
      }

      if(bgStyle) {
        this.previousFillStyle = bgStyle
        const x1 = p.screenPixelPos.x + xOffset
        const y1 = p.screenPixelPos.y + yOffset
        const x2 = x1 + maxSize
        const y2 = y1 + p.cellSizePixels.y
        this.drawFilledRect(
          new Rect(x1, y1 - 2, x2, y2 - 1), 
          bgStyle,
        )
      }

      if(style != this.previousFillStyle) {
        this.previousFillStyle = style
        ctx.fillStyle = style
      }

      if(this.previousFontStyle != p.fontStyle) {
        ctx.font = p.fontStyle.size + "px " + p.fontStyle.name;
      }
      this.previousFontStyle = p.fontStyle

      const textSize = ctx.measureText(textToDraw);
      const textWidth = textSize.width
      if(
        p.centerX
        && p.maxColumns > 0 
        && textWidth < maxSize
      ) {
        xOffset += Math.floor((maxSize - textWidth) / 2)
      }

      const textHeight = p.fontStyle.size
      if(
        p.centerY
        && false
        && p.cellSizePixels 
        && p.cellSizePixels.y > 0 && textHeight < p.cellSizePixels.y
      ) {
        yOffset += Math.floor((p.cellSizePixels.y - textHeight) / 2)
      }

      yOffset += p.fontStyle.size 

      if(
        p.centerY 
        && p.cellSizePixels 
        && p.cellSizePixels.y > 0
      ) {
        yOffset -= 0
          + textSize.actualBoundingBoxDescent 
          + (textHeight - textSize.actualBoundingBoxAscent) / 2
      }

      ctx.fillText(
        textToDraw, 
        p.screenPixelPos.x + xOffset + textOffset.x, 
        p.screenPixelPos.y + yOffset + textOffset.y,
      )

      p.screenPixelPos.x = p.screenPixelPos.x + maxSize

    }
  }

  drawEmptyRect(rect, style = "#000000") {
    if(style != ctx.stokeStyle) {
      ctx.strokeStyle = style
    }
    ctx.strokeRect(
      canvasProps.xOffset + rect.x1, 
      canvasProps.yOffset + rect.y1, 
      rect.width, 
      rect.height
      )
  }

  drawFilledRect(rect, style = "#000000") {
    if(style != ctx.stokeStyle) {
      ctx.strokeStyle = style
    }
    if(style != ctx.fillStyle) {
      ctx.fillStyle = style
    }
    ctx.fillRect(
      canvasProps.xOffset + rect.x1, 
      canvasProps.yOffset + rect.y1, 
      rect.width, 
      rect.height
      )
  }

  clearRect(rect) {
    ctx.clearRect(
      canvasProps.xOffset + rect.x1, 
      canvasProps.yOffset + rect.y1, 
      rect.width, 
      rect.height
      )
  }

}

function itemsEqual(item1, item2) {
  return item1.base === item2.base
}

function getNameOf(article, item, verb) {

  let name = item.name || item.base.name || 'Unknown Item'

  let count = item.count

  if(Number.isInteger(article)) {
    count = article
  }

  let of = null

  if(item.base && item.base.type == 'potion') {
    of = 'potion'
  }

  if(count != 1) {

    if(of) {
      of += 's'
    } else {
      name = name + 's'
    }

    if(article === null) {
      article = count
    }

    if(verb == 'is') verb = 'are'

  }

  if(of) {
    name = of + ' of ' + name
  }

  if(article) {
    name = article + ' ' + name
  }

  if(verb) {
    name += ' ' + verb
  }

  return name

}

const actions = {
  drop: {
    key: 'd',
    name: 'drop',
    supportMulti: true,
    execute: (item, count) => {
      topController.dropItem(item, count)
    },
  },
  drink: {
    key: 'q',
    name: 'drink',
    supportMulti: true,
    execute: (item, count) => {
      topController.drinkPotion(item, count)
    },
  },
  eat: {
    key: 'e',
    name: 'eat',
    supportMulti: true,
    execute: (item, count) => {
      topController.eatItem(item, count)
    },
  },
  equip: {
    key: 'e',
    name: 'equip',
    supportMulti: true,
    execute: (item) => {
      topController.equipItem(item)
    },
  },
  unequip: {
    key: 'u',
    name: 'unequip',
    supportMulti: true,
    execute: (item) => {
      topController.unequipItem(item)
    },
  },
}

function getActionsFor(type, allowMultiple) {
  switch(type) {
    case 'armor':
      return [ actions.drop, actions.equip, actions.unequip ]
      break
    case 'book':
      return [ actions.drop, actions.equip, actions.unequip ]
      break
    case 'food':
      return [ actions.drop, actions.eat ]
      break
    case 'jewelry':
      return [ actions.drop, actions.equip, actions.unequip ]
      break
    case 'wand':
      return [ actions.drop, actions.equip, actions.unequip ]
      break
    case 'potion':
      return [ actions.drop, actions.drink ]
      break
    case 'rock':
      return [ actions.drop, actions.equip, actions.unequip ]
      break
    case 'scroll':
      return [ actions.drop ]
      break
    case 'weapon':
      return [ actions.drop, actions.equip, actions.unequip ]
      break
    case 'tool':
      return [ actions.drop, actions.equip, actions.unequip ]
      break
    default:
      err('Invalid inventory type: ' + type)
      break
  }
}

function describeItem(item) {
  let message = item.base.showAs
  if(item.base.type) {
    message += ' ' + item.base.type + ' / '
  }
  message += item.base.name

  if(item.health) {
    message += ' hp=' + item.health
  }

  return message
}
  
const inventoryTypes = {
  a: 'armor',
  b: 'book',
  f: 'food',
  j: 'jewelry',
  m: 'wand',
  p: 'potion',
  r: 'rock',
  s: 'scroll',
  t: 'tool',
  w: 'weapon',
}

function generateLevelEmptyRoom(level, size, randomizer) {
  const ot = template.object
  for(let c = 0; c < size.x; c++) {
    level[c] = []
    for(let r = 0; r < size.y; r++) {
      if(c == 0 || r == 0 || c == size.x - 1 || r == size.y - 1) {
        level[c][r] = { 
          occupiedBy: { base: ot.rockWall }, 
          onFloor: [], 
          floorType: { base: ot.dirtFloor },
        }
      } else {
        level[c][r] = { 
          occupiedBy: null, 
          onFloor: [], 
          floorType: { base: ot.dirtFloor },
        }
      }
    }
  }
}

function generateDiamondSquareMap(fromMap, randomizer) {
  let toMap = []
  let fromWidth = fromMap.length
  let fromHeight = fromMap[0].length

  // calculate center of each square
  for(let fromX = 0; fromX < fromWidth; fromX++) {

    // even column
    let toMapColumn = []
    toMap.push(toMapColumn)
    for(let fromY = 0; fromY < fromHeight; fromY++) {
      let fromMapValue = fromMap[fromX][fromY]

      // top left
      toMapColumn[fromY * 2] = fromMapValue

      // left: do nothing
    }

    if(fromX < fromWidth - 1) {
      // odd column
      toMapColumn = []
      toMap.push(toMapColumn)
      for(let fromY = 0; fromY < fromHeight; fromY++) {
        let values = []
        values.push(fromMap[fromX][fromY])
        values.push(fromMap[fromX+1][fromY])
        values.push(fromMap[fromX][fromY+1])
        values.push(fromMap[fromX+1][fromY+1])

        let randomValue = randomizer.next()
        values.push(randomValue)

        let averageValue = values.reduce((a,b) => a + b, 0) / values.length

        // top: do nothing

        if(fromY < fromHeight - 1) {
          // center
          toMapColumn[fromY * 2 + 1] = averageValue
        }
      }
    }

  }

  // calculate sides of each square
  const toWidth = toMap.length
  const toHeight = toMap[0].length

  for(let x = 0; x < toWidth; x++) {
    for(let y = 0; y < toHeight; y++) {
      if(toMap[x][y] == null) {
        let values = []
        if(x-1 > 0 && toMap[x-1][y] != null) {
          values.push(toMap[x-1][y])
        }
        if(x+1 < toWidth && toMap[x+1][y] != null) {
          values.push(toMap[x+1][y])
        }
        if(y-1 > 0 && toMap[x][y-1] != null) {
          values.push(toMap[x][y-1])
        }
        if(y+1 < toHeight && toMap[x][y+1] != null) {
          values.push(toMap[x][y+1])
        }

        let randomValue = randomizer.next()
        values.push(randomValue)

        let averageValue = values.reduce((a,b) => a + b, 0) / values.length

        toMap[x][y] = averageValue
      }
    }
  }

  return toMap
}

function reduceMap(fromMap) {
  let toMap = []
  let fromWidth = fromMap.length
  let fromHeight = fromMap[0].length

  for(let fromX = 0; fromX < fromWidth - 1; fromX += 2) {
    let toMapColumn = []
    toMap.push(toMapColumn)
    for(let fromY = 0; fromY < fromHeight - 1; fromY += 2) {
      let values = []
      values.push(fromMap[fromX][fromY])
      values.push(fromMap[fromX + 1][fromY])
      values.push(fromMap[fromX][fromY + 1])
      values.push(fromMap[fromX + 1][fromY + 1])

      let minValue = values.reduce((a,b) => Math.min(a, b), 1)
      toMapColumn.push(minValue)
    }
  }
 
  return toMap
}

function removeIsolatedWalls(fromMap, wallThreshold, requireSurroundingWalls) {
  let size = new Pair(fromMap.length, fromMap[0].length)
  let iterationsLeft = 5

  let toMap
  let removed = 0
  while(true) {
    toMap = []
    for(let fromX = 0; fromX < size.x; fromX++) {
      let toMapColumn = []
      toMap.push(toMapColumn)
      for(let fromY = 0; fromY < size.y; fromY++) {
        let adjacent = new Pair(fromX, fromY).adjacent(size)
        let surroundingWalls = adjacent.reduce(
          (a,b) => {
            if(fromMap[b.x][b.y] > wallThreshold) {
              return a + 1
            } else {
              return a
            }
          }, 0
        )

        let value = fromMap[fromX][fromY]
        if(value > wallThreshold && surroundingWalls < requireSurroundingWalls) {
          value = 0
          removed++
        }

        toMapColumn.push(value)
      }
    }

    if(removed > 0) {
      debug("Removed " + removed + " stray walls.")
      fromMap = toMap
      iterationsLeft--
      if(iterationsLeft > 0) {
        removed = 0
        continue
      }
    }
    break
  } 
   
  return toMap
}

function classifyLevelSpaces(level, pos, classifiedSpaces = null) {
  let levelSize = new Pair(level.length, level[0].length)

  if(classifiedSpaces == null) {
    classifiedSpaces = []
    for(let x = 0; x < level.length; x++) {
      let column = level[x]
      classifiedSpaces[x] = []
      for(let y = 0; y < column.length; y++) {
        classifiedSpaces[x][y] = false
      }
    }
  }

  classifiedSpaces[pos.x][pos.y] = true
  const adjacentList = pos.adjacent(levelSize)
  for(let adjacentPos of adjacentList) {
    const occupied = level[adjacentPos.x][adjacentPos.y].occupiedBy
    const classified = classifiedSpaces[adjacentPos.x][adjacentPos.y]
    if(!classified && !occupied) {
      classifyLevelSpaces(level, adjacentPos, classifiedSpaces)
    }
  }

  return classifiedSpaces
}

// returns null if no unclassified space exists
function findBestCrack(level, map, classifiedSpaces, wallThreshold) {
  let pos = null
  let weakestWall = null
  const levelSize = new Pair(level.length, level[0].length)

  for(let x = 0; x < level.length; x++) {
    for(let y = 0; y < level[x].length; y++) {
      if(classifiedSpaces[x][y] == false && !level[x][y].occupiedBy) {
        let newPos = new Pair(x, y)
        for(let adjacentPos of newPos.adjacent(levelSize)) {
          let wallStrength = map[adjacentPos.x][adjacentPos.y]
          if(wallStrength <= wallThreshold) {
            // not a wall, so we don't care
            continue
          }
          if(weakestWall == null || wallStrength < weakestWall) {
            pos = newPos
            weakestWall = wallStrength
          }
        }
      }
    }
  }

  return pos
}

function expandCrack(level, map, classifiedSpaces, wallThreshold, startPos) {
  let pos = null
  let weakestWall = null
  const levelSize = new Pair(level.length, level[0].length)

  for(let adjacentPos of startPos.adjacent(levelSize)) {
    if(classifiedSpaces[adjacentPos.x][adjacentPos.y]) {
      // already connected, we are done here

      // fill any adjacent unclassified spaces
      classifyLevelSpaces(level, adjacentPos, classifiedSpaces)

      return true
    }

    let wallStrength = map[adjacentPos.x][adjacentPos.y]
    if(wallStrength <= wallThreshold) {
      // not a wall, so we don't care
      continue
    }
    if(weakestWall == null || wallStrength < weakestWall) {
      pos = adjacentPos
      weakestWall = wallStrength
    }
  }

  if(pos) {
    map[pos.x][pos.y] = 0
    level[pos.x][pos.y].occupiedBy = null
    return expandCrack(level, map, classifiedSpaces, wallThreshold, pos)
  }

  // we didn't find any cracks that we could expand successfully
  return false
}

function connectRooms(level, map, wallThreshold, randomizer) {
  let startingPoint = findEmptyCellCentrally(level, randomizer)
  let classifiedSpaces = classifyLevelSpaces(level, startingPoint)
  
  let maxIterations = 10
  let connectedRooms = 0
  while(true) {
    let pos = findBestCrack(level, map, classifiedSpaces, wallThreshold)
    if(!pos) {
      break
    }

    let success = expandCrack(level, map, classifiedSpaces, wallThreshold, pos)
    if(success) {
      connectedRooms++
      continue
    }

    if(maxIterations-- == 0) {
      warn('Ran out of iterations to connectRooms')
      break
    }
  }

  if(connectedRooms) {
    debug('Connected ' + connectedRooms + ' rooms')
  }
}

function mapToLevel(map, level, wallThreshold, size) {
  const ot = template.object
  for(let c = 0; c < size.x; c++) {
    level[c] = []
    for(let r = 0; r < size.y; r++) {
      if(map[c][r] > wallThreshold) {
        level[c][r] = { 
          occupiedBy: { base: ot.rockWall }, 
          onFloor: [], 
          floorType: { base: ot.dirtFloor }, 
        }
      } else {
        level[c][r] = { 
          occupiedBy: null, 
          onFloor: [], 
          floorType: { base: ot.dirtFloor },
        }
      }
    }
  }
}

function surroundLevelWithWalls(oldLevel, size) {
  const ot = template.object
  let level = []
  for(let c = 0; c < size.x + 2; c++) {
    level[c] = []
    for(let r = 0; r < size.y + 2; r++) {
      if(c == 0 || r == 0 || c == size.x + 1 || r == size.y + 1) {
        level[c][r] = { 
          occupiedBy: { base: ot.rockWall }, 
          onFloor: [], 
          floorType: { base: ot.dirtFloor },
        }
      } else {
        level[c][r] = oldLevel[c-1][r-1]
      }
    }
  }

  return level
}

function generateLevelSimpleCaves(level, size, randomizer, levelCaveGenerator) {
  const ot = template.object
  const b = 1 - levelCaveGenerator.openness
  const wallThreshold = levelCaveGenerator.wallThreshold
  const requireSurroundingWalls = levelCaveGenerator.requireSurroundingWalls

  let map = [[b, b], [b, b]]

  while(map.length < size.x) {
    map = generateDiamondSquareMap(map, randomizer)
  }

  // generate an extra level of data
  map = generateDiamondSquareMap(map, randomizer)
  // smooth out the results using the extra level of data
  map = reduceMap(map)
  map = removeIsolatedWalls(map, wallThreshold, requireSurroundingWalls)
  mapToLevel(map, level, wallThreshold, size)
  connectRooms(level, map, wallThreshold, randomizer)
  // level = surroundLevelWithWalls(level, size)
  return level
}

// returns an empty position, or null if no position can be found
function findEmptyCellSimple(level) {
  for(let c = 0; c < level.length; c++) {
    let column = level[c]
    for(let r = 0; r < column.length; r++) {
      let cell = column[r]
      if(cell.occupiedBy == null && cell.onFloor.length == 0) {
        return new Pair(c, r)
      }
    }
  }

  return null
}

// returns an empty position, or null if no position can be found
function findEmptyCellCentrally(level, randomizer, bounds = null) {
  if(bounds == null) {
    const height = level.length
    const width = level[0].length

    bounds = new Rect(0, 0, width, height)
  }

  const middlePos = bounds.center
  const cellToTest = level[middlePos.x][middlePos.y]

  if(cellToTest.occupiedBy == null && cellToTest.onFloor.length == 0) {
    return middlePos
  }

  if(bounds.width < 2 || bounds.height < 2) {
    // too small to subdivide further
    return null
  }

  let newBounds
  let allResults = [] 
  let result

  newBounds = bounds.upperLeftQuarter()
  result = findEmptyCellCentrally(level, randomizer, newBounds)
  if(result) allResults.push(result)

  newBounds = bounds.upperRightQuarter()
  result = findEmptyCellCentrally(level, randomizer, newBounds)
  if(result) allResults.push(result)

  newBounds = bounds.lowerLeftQuarter()
  result = findEmptyCellCentrally(level, randomizer, newBounds)
  if(result) allResults.push(result)

  newBounds = bounds.lowerRightQuarter()
  result = findEmptyCellCentrally(level, randomizer, newBounds)
  if(result) allResults.push(result)

  if(allResults.length > 0) {
    return allResults[randomizer.next(allResults.length)]
  }

  return null
}

function clearArray(array) {
  array.splice(0, array.length)
}

function splitAtBlankBefore(string, pos) {

  let breakPoint = -1
  let result

  if(typeof string == 'string') {

    for(let i = pos; i > 0; i--) {
      if(string[i] == ' ') {
        breakPoint = i
        break
      }
    }

    if(breakPoint > -1) {
      result = [ string.substring(0, breakPoint), string.substring(breakPoint+1) ]
    } else {
      result = [ string, '' ]
    }

  } else {

    const list = string
    for(let i = list.length - 1; i >= 0; i--) {
      if(complexLength(list.slice(0, i)) <= pos) {
        breakPoint = i
        break
      }
    }

    if(breakPoint > -1) {
      result = [ list.slice(0, breakPoint), list.slice(breakPoint) ]
    } else {
      result = [ list, [] ]
    }

  }

  return result
}

function complexLength(list) {
  let total = 0
  for(let item of list) {
    if(item.text) {
      total += item.text.length
    } else {
      total += complexLength(item)
    }
  }
  return total
}

function complexJoin(list, pad={text:' '}) {
  let result = []
  for(let item of list) {
    if(result.length > 0) {
      result.push(pad)
    }
    result.push(...item)
  }
  return result
}

function getChannelFlowFromMagnitude(mag, max) {
  return 3**(mag-9) * max
}

// immutable
class Rect {
  // x1, y1 are inclusive
  // x2, y2 are exclusive (are not part of this rectangle)
  constructor(x1, y1, x2, y2) {
    this.x1 = x1
    this.y1 = y1
    this.x2 = x2
    this.y2 = y2

    const xa = Math.floor((this.x1 + this.x2)/2)
    const ya = Math.floor((this.y1 + this.y2)/2)
    this.center = new Pair(xa, ya)
    this.width = x2 - x1
    this.height = y2 - y1
  }

  upperLeftQuarter() {
    const newX1 = this.x1
    const newY1 = this.y1
    const newX2 = this.center.x
    const newY2 = this.center.y
    return new Rect(newX1, newY1, newX2, newY2)
  }

  upperRightQuarter() {
    const newX1 = this.center.x
    const newY1 = this.y1
    const newX2 = this.x2
    const newY2 = this.center.y
    return new Rect(newX1, newY1, newX2, newY2)
  }

  lowerLeftQuarter() {
    const newX1 = this.x1
    const newY1 = this.center.y
    const newX2 = this.center.x
    const newY2 = this.y2
    return new Rect(newX1, newY1, newX2, newY2)
  }

  lowerRightQuarter() {
    const newX1 = this.center.x
    const newY1 = this.center.y
    const newX2 = this.x2
    const newY2 = this.y2
    return new Rect(newX1, newY1, newX2, newY2)
  }

  expand(pixels) {
    const newX1 = this.x1 - pixels
    const newY1 = this.y1 - pixels
    const newX2 = this.x2 + pixels
    const newY2 = this.y2 + pixels
    return new Rect(newX1, newY1, newX2, newY2)
  }

  add(pair) {
    if(!pair) return this
    return new Rect(this.x1 + pair.x, this.y1 + pair.y, this.x2 + pair.x, this.y2 + pair.y)
  }
}

function poolIndexToName(poolIndex) {
  let index = 0
  for(let key of Object.keys(pools)) {
    if(index == poolIndex) return key
    index++
  }
  return null
}

function poolNameToIndex(poolName) {
  let index = 0
  for(let key of Object.keys(pools)) {
    if(key == poolName) return index
    index++
  }
  return -1
}

function getBias(actor, fromPool, toPool) {
  let upBias = 0
  let downBias = fromPool.tier > toPool.tier ? 1 : 0
  if(actor.focus === fromPool) upBias += Math.floor(actor.medDepth + 1)
  if(actor.focus === toPool) downBias += Math.floor(actor.medDepth + 1)
  return { upBias: upBias, downBias: downBias }
}

// returns [fromPressure, toPressure]
function getEffectivePressures(actor, fromPool, toPool) {
  const poolIndexFrom = poolNameToIndex(fromPool.name)
  const poolIndexTo = poolNameToIndex(toPool.name)
  const fCur = actor.poolCurrent[poolIndexFrom]
  const tCur = actor.poolCurrent[poolIndexTo]
  const fMax = getPoolMax(actor, poolIndexToName(poolIndexFrom))
  const tMax = getPoolMax(actor, poolIndexToName(poolIndexTo))
  const bias = getBias(actor, fromPool, toPool)
  const upBias = bias.upBias
  const downBias = bias.downBias
  const fPress = fCur / (fMax * (1 + upBias))
  const tPress = tCur / (tMax * (1 + downBias))
  return [fPress, tPress]
}

function poolAtMax(actor, poolName) {
  const poolIndex = poolNameToIndex(poolName)
  const current = getPoolCurrent(actor, poolIndex)
  const max = getPoolMax(actor, poolName)
  return current > max - 1
}

function getPoolCurrent(actor, poolIndex) {
  return actor.poolCurrent[poolIndex]
}

function getPoolMax(
  actor, 
  poolName, 
  boost = 0, 
  handleDependencies = false
) {
  let value
  const poolIndex = poolNameToIndex(poolName)
  const current = getPoolCurrent(actor, poolIndex)

  if(
    handleDependencies &&
    (
      poolName == 'majorHealth'
      && !poolAtMax(actor, 'criticalHealth')
      ||
      poolName == 'minorHealth'
      && (
        !poolAtMax(actor, 'criticalHealth')
        || !poolAtMax(actor, 'majorHealth')
      )
    )
  ) {
    value = current
  } else {
    value = actor.poolMax[poolIndex]
    if(actor.growth) {
      let growth = actor.growth.poolCapacity[poolName]
      growth += boost
      value *= 1.1 ** growth
    }
    if(
      actor.awakenedPools 
      && actor.awakenedPools.find(x => x == pools[poolName])
    ) {
      value *= 3
    }
  }
  return Math.floor(value)
}

function getEnergyEfficiency(actor, poolName, boost = 0) {
  const poolIndex = poolNameToIndex(poolName)
  let value = 
    actor.species.energyEfficiency[poolName]
    || actor.species.energyEfficiency.default
  if(actor.growth) {
    let growth = actor.growth.energyEfficiency[poolName]
    growth += boost
    value *= 1.1 ** growth
  }
  if(
    actor.awakenedPools 
    && actor.awakenedPools.find(x => x == pools[poolName])
  ) {
    value *= 3
  }
  return autoRound(value)
}

function getChannelMaxFlow(actor, channelName, boost = 0) {
  const channel = getPoolChannelByName(channelName)
  const channelIndex = channel.index
  let value = actor.channelMax[channelIndex]
  if(actor.growth) {
    let growth = actor.growth.channelMaxFlow[channelName]
    growth += boost
    value *= 1.1 ** growth
  }
  let awakened = false
  if(actor.awakenedPools) {
    out: for(let aPool of actor.awakenedPools) {
      for(let cPool of channel.from) {
        if(cPool == aPool) {
          awakened = true
          break out
        }
      }
      for(let cPool of channel.to) {
        if(cPool == aPool) {
          awakened = true
          break out
        }
      }
    }
  }
  if(awakened) value *= 3
  return autoRound(value)
}

function text(t) {
  return { text: t }
}

function colorizePoolName(pool) {
  return {
    style: pool.color.style,
    bgStyle: pool.color.bgStyle,
    text: pool.shortName,
  }
}

function getChannelString(player, from, to) {

  const [fPress, tPress] = getEffectivePressures(
    player, 
    from, 
    to,
  )

  let direction
  if(fPress > tPress + 0.01) {
    direction = '>'
  } else if(tPress > fPress + 0.01) {
    direction = '<'
  } else {
    direction = '='
  }

  let channelString = [ 
    colorizePoolName(from),
    text(direction),
    colorizePoolName(to),
  ]

  return channelString

}

function getGrowthSelectCount(growthSelection) {
  let selected = 0
  let total = 0
  for(let key in growthSelection) {
    const value = growthSelection[key]
    if(typeof value == 'boolean') {
      if(value) selected++
      total++
    } else {
      const [selected2, total2] = getGrowthSelectCount(value)
      selected += selected2
      total += total2
    }
  }
  return [selected, total]
}

function getPoolChannelByName(channelName) {
  let result = null
  for(let i in poolChannels) {
    const channel = poolChannels[i]
    if(channel.name == channelName) {
      result = channel
      break
    }
  }
  if(result == null) {
    err("Couldn't find channel " + channelName)
  }
  return result
}

function autoRound(n) {
  if(n >= 10) {
    return Math.floor(n)
  } else if(n >= 1) {
    return Math.floor(n*10)/10
  } else if(n >= 0.1) {
    return Math.floor(n*100)/100
  } else if(n >= 0.01) {
    return Math.floor(n*1000)/1000
  } else if(n >= 0.001) {
    return Math.floor(n*10000)/10000
  } else {
    return 0
  }
}

function fill(objectOrArray, value) {
  for(i in objectOrArray) {
    objectOrArray[i] = value
  }
}

function wrap(n, size) {
  let iterations = 10
  while(n < 0) {
    n += size
    iterations--
    if(!iterations) {
      err("Too many iterations")
    }
  }
  while(n >= size) {
    n -= size
    iterations--
    if(!iterations) {
      err("Too many iterations")
    }
  }
  return n
}

// sets a value for a multi-dimensional dimensional array, creating
// intermediate arrays as needed
function set(array, indexes, value) {
  array ?? err("You must pass in a non-null array to set()")
  let currentArray = array
  const lastIndex = indexes.length - 1
  for(let i = 0; i < lastIndex; i++) {
    const index = indexes[i]
    if(currentArray[index] == undefined) {
      currentArray[index] = []
    }
    currentArray = currentArray[index]
  }
  currentArray[indexes[lastIndex]] = value
}

let didSomething = false

// this class handles all lines, including vertical ones
class Line {

  // either define slope and yIntercept 
  //   OR xIntercept (for veritcal lines)
  constructor(slope, yIntercept, xIntercept) {
    this.slope = slope
    this.yIntercept = yIntercept
    this.xIntercept = xIntercept
  }

  interceptsSegment(segment) {
    const line = this.fromSegment(segment)
    const intersection = this.intersection(line).round(5)
    const intercepts = 
      intersection != null
      && 
      ( 
        intersection.x >= segment.pos1.x 
        && (
          intersection.x < segment.pos2.x 
          || segment.pos1.x == segment.pos2.x
        )
        ||
        intersection.x <= segment.pos1.x 
        && (
          intersection.x > segment.pos2.x 
          || segment.pos1.x == segment.pos2.x
        )
      )
      && 
      ( 
        intersection.y >= segment.pos1.y 
        && (
          intersection.y < segment.pos2.y 
          || segment.pos1.y == segment.pos2.y
        )
        ||
        intersection.y <= segment.pos1.y 
        && (
          intersection.y > segment.pos2.y 
          || segment.pos1.y == segment.pos2.y
        )
      )
    return intercepts
  }

  fromSegment(segment) {
    const dx = segment.pos2.x - segment.pos1.x
    let line
    if(dx == 0)  {
      line = new Line(null, null, segment.pos1.x)
    } else {
      const dy = segment.pos2.y - segment.pos1.y
      const slope = dy / dx
      const yIntercept = segment.pos1.y - slope * segment.pos1.x
      line = new Line(slope, yIntercept)
    }
    return line
  }

  intersection(line) {
    let intersection
    if(this.slope != null && line.slope != null) {
      if(this.slope != line.slope) {
        const x = 
          (line.yIntercept - this.yIntercept) 
          / (this.slope - line.slope)
        const y = this.slope * x + this.yIntercept
        intersection = new Pair(x, y)
      } // otherwise the slopes are parallel
        //   and there is no intersection
    } else if(this.slope != null && line.slope == null) {
      const x = line.xIntercept
      const y = this.slope * x + this.yIntercept
      intersection = new Pair(x, y)
    } else if(this.slope == null && line.slope != null) {
      const x = this.xIntercept
      const y = line.slope * x + line.yIntercept
      intersection = new Pair(x, y)
    } // otherwise both slopes are vertical, and we don't
      //   have an intersection
    return intersection
  }

}

class Segment {
  constructor(pos1, pos2) {
    this.pos1 = pos1
    this.pos2 = pos2
  }
}

function getEnergyCapacityFlow(h1, c1, h2, c2) {
  const d = (h2 - h1) / (c2 + c1)
  const from = d / c1
  const to =  -d / c2
  return [from, to]
}

const topController = new TopController()

</script>

</body>
</html>
